        -:    0:Source:myfilesystem.c
        -:    0:Programs:4
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <sys/types.h>
        -:    5:#include <sys/stat.h>
        -:    6:#include <fcntl.h>
        -:    7:#include <unistd.h>
        -:    8:#include <pthread.h>
        -:    9:#include <sys/mman.h>
        -:   10:#include <assert.h>
        -:   11:
        -:   12:#include "structs.h"
        -:   13:#include "helper.h"
        -:   14:#include "arr.h"
        -:   15:#include "myfilesystem.h"
        -:   16:
        -:   17:/*
        -:   18: * Filesystem Implementation
        -:   19: *
        -:   20: * This filesystem only uses one mutex lock for all read and write operations.
        -:   21: * Write operations require exclusive control of the filesystem as they have
        -:   22: * the potential to modify some or all of the underlying filesystem files
        -:   23: * (file_data, dir_table, hash_data). Additionally, the use of a mutex during
        -:   24: * read operations was considered more appropriate than a lock which allows
        -:   25: * parallel reads, as in the event that multiple threads attempt to read to the
        -:   26: * same buffer simultaneously, the integrity of the buffer is only guaranteed
        -:   27: * if both read operations are blocking and run in serialised. Hence, only one
        -:   28: * mutex was used for the synchronisation of the filesystem.
        -:   29: */
        -:   30:
       31:   31:void * init_fs(char * f1, char * f2, char * f3, int n_processors) {
        -:   32:    // Allocate space for filesystem helper
       31:   33:	filesys_t* fs = salloc(sizeof(*fs));
        -:   34:	
        -:   35:	// Initialise filesystem lock
       31:   36:	pthread_mutex_init(&fs->lock, NULL);
        -:   37:	
        -:   38:	// Check if files exist
       31:   39:	fs->file_fd = open(f1, O_RDWR);
       31:   40:	fs->dir_fd = open(f2, O_RDWR);
       31:   41:	fs->hash_fd = open(f3, O_RDWR);
       31:   42:	assert(fs->file_fd >= 0 && fs->dir_fd >= 0 &&
        -:   43:	       fs->hash_fd >= 0 && "failed to open files");
        -:   44:
        -:   45:	// Store file lengths in filesystem
       31:   46:	struct stat stats[3];
       31:   47:	assert(!fstat(fs->file_fd, &stats[0]) &&
        -:   48:		   !fstat(fs->dir_fd, &stats[1]) &&
        -:   49:		   !fstat(fs->hash_fd, &stats[2]) && "failed to get file lengths");
        -:   50:
       31:   51:	fs->file_data_len = stats[0].st_size;
       31:   52:	fs->dir_table_len = stats[1].st_size;
       31:   53:	fs->hash_data_len = stats[2].st_size;
        -:   54:	
        -:   55:	// Map files to memory using mmap
       31:   56:	fs->file = mmap(NULL, fs->file_data_len, PROT_READ | PROT_WRITE,
        -:   57:			MAP_SHARED, fs->file_fd, 0);
       31:   58:	fs->dir = mmap(NULL, fs->dir_table_len, PROT_READ | PROT_WRITE,
        -:   59:			MAP_SHARED, fs->dir_fd, 0);
       31:   60:	fs->hash = mmap(NULL, fs->hash_data_len, PROT_READ | PROT_WRITE,
        -:   61:			MAP_SHARED, fs->hash_fd, 0);
       31:   62:	assert(fs->file != MAP_FAILED && fs->dir != MAP_FAILED &&
        -:   63:		   fs->hash != MAP_FAILED && "mmap failed");
        -:   64:
        -:   65:	// Initialise filesystem variables
       31:   66:	fs->n_processors = n_processors;
       31:   67:	fs->index_len = fs->dir_table_len / META_LEN;
       31:   68:	fs->index_count = 0;
       31:   69:	fs->index = scalloc(sizeof(*fs->index) * fs->index_len);
       31:   70:	fs->o_list = arr_init(fs->index_len, OFFSET, fs);
       31:   71:	fs->n_list = arr_init(fs->index_len, NAME, fs);
       31:   72:	fs->used = 0;
       31:   73:	fs->tree_len = fs->hash_data_len / HASH_LEN;
       31:   74:	fs->leaf_offset = fs->tree_len / 2;
        -:   75:	UNUSED(fs->n_processors);
        -:   76:
        -:   77:	// Read through dir_table for existing files
       31:   78:	char name[NAME_LEN] = {0};
       31:   79:	uint64_t offset = 0;
       31:   80:	uint32_t length = 0;
      341:   81:	for (int32_t i = 0; i < fs->index_len; ++i) {
        -:   82:		// Copy 63 characters from name field of dir_table entry
      310:   83:		memcpy(&name, fs->dir + i * META_LEN, NAME_LEN - 1);
        -:   84:		
        -:   85:		// Valid filenames do not start with a null byte
      310:   86:		if (name[0] != '\0') {
        2:   87:			memcpy(&length, fs->dir + i * META_LEN + NAME_LEN + OFFSET_LEN,
        -:   88:					sizeof(uint32_t));
        -:   89:			
        -:   90:			// Assign max length of file_data as offset for zero size files
        -:   91:			// See arr.c for justification
        2:   92:			if (length == 0) {
        1:   93:				offset = MAX_FILE_DATA_LEN;
        -:   94:			} else {
        1:   95:				memcpy(&offset, fs->dir + i * META_LEN + NAME_LEN,
        -:   96:						sizeof(uint32_t));
        -:   97:
        -:   98:				// Ensure remaining bytes in offset uint64_t are 0
        1:   99:				memset((uint8_t*)(&offset) + sizeof(uint32_t), 0,
        -:  100:						sizeof(uint32_t));
        -:  101:			}
        -:  102:			
        -:  103:			// Create file_t and add to sorted arrays
        2:  104:			file_t* f = file_init(name, offset, length, i);
        2:  105:			arr_sorted_insert(f, fs->o_list);
        2:  106:			arr_sorted_insert(f, fs->n_list);
        -:  107:			
        -:  108:			// Updating filesystem variables
        2:  109:			fs->used += f->length;
        2:  110:			fs->index[i] = 1;
        2:  111:			++fs->index_count;
        -:  112:		}
        -:  113:	}
        -:  114:	
       31:  115:	return fs;
        -:  116:}
        -:  117:
       32:  118:void close_fs(void * helper) {
        -:  119:	// Return if helper is NULL
       32:  120:	if (helper == NULL) {
        1:  121:		return;
        -:  122:	}
        -:  123:	
       31:  124:	filesys_t* fs = (filesys_t*)helper;
        -:  125:	
       31:  126:	munmap(fs->file, fs->file_data_len);
       31:  127:	munmap(fs->dir, fs->dir_table_len);
       31:  128:	munmap(fs->hash, fs->hash_data_len);
        -:  129:	
       31:  130:	close(fs->file_fd);
       31:  131:	close(fs->dir_fd);
       31:  132:	close(fs->hash_fd);
        -:  133:	
       31:  134:	pthread_mutex_destroy(&fs->lock);
        -:  135:	
       31:  136:	free_arr(fs->o_list);
       31:  137:	free_arr(fs->n_list);
       31:  138:	free(fs->index);
       31:  139:	free(fs);
        -:  140:}
        -:  141:
        -:  142:/*
        -:  143: * Returns first empty index in dir_table
        -:  144: *
        -:  145: * returns: Lowest empty index in dir_table
        -:  146: */
       59:  147:int32_t new_file_index(filesys_t* fs) {
       59:  148:	assert(fs != NULL && "invalid args");
        -:  149:
        -:  150:	// Iterate over index array for dir_table
       59:  151:	int32_t index = -1;
       59:  152:	int32_t len = fs->index_len;
       59:  153:	uint8_t* arr = fs->index;
      171:  154:	for (int32_t i = 0; i < len; ++i) {
      171:  155:		if (arr[i] == 0) {
       59:  156:			index = i;
       59:  157:			break;
        -:  158:		}
        -:  159:	}
        -:  160:
       59:  161:	assert(index >= 0 && "dir_table full");
       59:  162:	return index;
        -:  163:}
        -:  164:
        -:  165:/*
        -:  166: * Returns offset in file_data for insertion
        -:  167: *
        -:  168: * length: length of new file
        -:  169: * hash_offset: pointer to variable storing offset of first modified
        -:  170: * 				byte in file_data
        -:  171: *
        -:  172: * returns: valid file_data offset for new file, repacking if required
        -:  173: */
       68:  174:uint64_t new_file_offset(size_t length, int64_t* hash_offset, filesys_t* fs) {
       68:  175:	assert(fs != NULL && length <= fs->file_data_len && "invalid args");
       68:  176:	assert(fs->used + length <= fs->file_data_len &&
        -:  177:	       "insufficient space in file_data");
        -:  178:
        -:  179:	// Return max length of file_data for zero size files
       68:  180:	if (length == 0) {
       25:  181:		return MAX_FILE_DATA_LEN;
        -:  182:	}
        -:  183:
        -:  184:	// Find offset of first non-zero size file
       43:  185:	int32_t size = fs->o_list->size;
       43:  186:	file_t* first_non_zero_file = find_next_nonzero_file(0, fs->o_list);
        -:  187:	
        -:  188:	// Return 0 if no files, only zero size files, or if first non-zero size
        -:  189:	// file offset is large enough
       65:  190:	if (size <= 0 || first_non_zero_file == NULL ||
       22:  191:			first_non_zero_file->offset >= length) {
       21:  192:		return 0;
        -:  193:	}
        -:  194:
        -:  195:	// Increment index and check space between remaining elements in
        -:  196:	// the offset array
       22:  197:	uint64_t start_curr_file = 0;
       22:  198:	uint64_t end_prev_file = 0;
       22:  199:	file_t* prev_non_zero_file = first_non_zero_file;
       22:  200:	file_t* curr_non_zero_file = NULL;
       22:  201:	int32_t search_index = first_non_zero_file->o_index + 1;
       61:  202:	while ((curr_non_zero_file =
       39:  203:			find_next_nonzero_file(search_index, fs->o_list)) != NULL) {
       18:  204:		start_curr_file = curr_non_zero_file->offset;
       18:  205:		end_prev_file =
       18:  206:				prev_non_zero_file->offset + prev_non_zero_file->length;
        -:  207:
        -:  208:		// Return offset of first byte after end of previous
        -:  209:		// file if sufficient space
       18:  210:		if (start_curr_file - end_prev_file >= length) {
        1:  211:			return end_prev_file;
        -:  212:		}
        -:  213:
       17:  214:		prev_non_zero_file = curr_non_zero_file;
       17:  215:		search_index = curr_non_zero_file->o_index + 1;
        -:  216:	}
        -:  217:	
        -:  218:	// Check space between last non-zero size file in offset list and the end
        -:  219:	// of file_data
       21:  220:	uint64_t end_last_file =
       21:  221:			prev_non_zero_file->offset + prev_non_zero_file->length;
        -:  222:
       21:  223:	if (fs->file_data_len - end_last_file >= length) {
       19:  224:		return end_last_file;
        -:  225:	}
        -:  226:	
        -:  227:	// Repack file_data if no large enough contiguous space found
        2:  228:	if (hash_offset != NULL) {
        1:  229:		*hash_offset = repack_helper(fs);
        -:  230:	} else {
        1:  231:		repack_helper(fs);
        -:  232:	}
        -:  233:	
        -:  234:	// Return offset of first byte after bytes used in filesystem
        2:  235:	return fs->used;
        -:  236:}
        -:  237:
       63:  238:int create_file(char * filename, size_t length, void * helper) {
       63:  239:	filesys_t* fs = (filesys_t*)helper;
       63:  240:	LOCK(&fs->lock);
        -:  241:
        -:  242:	// Return 1 if file already exists
       63:  243:	file_t temp;
       63:  244:	update_file_name(filename, &temp);
       63:  245:	if (arr_get_by_key(&temp, fs->n_list) != NULL) {
        2:  246:		UNLOCK(&fs->lock);
        2:  247:		return 1;
        -:  248:	}
        -:  249:	
        -:  250:	// Return 2 if insufficient space in file_data or dir_table
      121:  251:	if (fs->used + length > fs->file_data_len ||
       60:  252:		fs->index_count >= fs->index_len) {
        2:  253:		UNLOCK(&fs->lock);
        2:  254:		return 2;
        -:  255:	}
        -:  256:	
        -:  257:	// Find available index in dir_table and space in file_data
       59:  258:	int64_t hash_offset = -1;
       59:  259:	int32_t index = new_file_index(fs);
       59:  260:	uint64_t offset = new_file_offset(length, &hash_offset, fs);
        -:  261:
        -:  262:	// Create new file_t struct and insert into both sorted lists
       59:  263:	file_t* f = file_init(filename, offset, length, index);
       59:  264:	arr_sorted_insert(f, fs->o_list);
       59:  265:	arr_sorted_insert(f, fs->n_list);
        -:  266:
        -:  267:	// Write file metadata to dir_table and update index array
       59:  268:	write_dir_file(f, fs);
       59:  269:	fs->index[index] = 1;
       59:  270:	++fs->index_count;
        -:  271:
        -:  272:	// Only perform file_data updates for non-zero size files
       59:  273:	if (length > 0) {
        -:  274:		// Write null bytes to file_data and update filesystem variables
       42:  275:		write_null_byte(fs->file, offset, length);
       42:  276:		fs->used += length;
        -:  277:
       42:  278:		if (hash_offset >= 0) {
        -:  279:			// Hash blocks modified by repack until end of file
        1:  280:			compute_hash_block_range(hash_offset, fs->used - hash_offset, fs);
        -:  281:		} else {
        -:  282:			// Only hash blocks containing the file
       41:  283:			compute_hash_block_range(offset, length, fs);
        -:  284:		}
        -:  285:	}
        -:  286:	
       59:  287:	msync(fs->file, fs->file_data_len, MS_ASYNC);
       59:  288:	msync(fs->dir, fs->dir_table_len, MS_ASYNC);
       59:  289:	msync(fs->hash, fs->hash_data_len, MS_ASYNC);
        -:  290:	
       59:  291:	UNLOCK(&fs->lock);
       59:  292:	return 0;
        -:  293:}
        -:  294:
        -:  295:/*
        -:  296: * Helper for resizing files, independent of the filesystem lock state
        -:  297: *
        -:  298: * file: file_t of file being resized
        -:  299: * length: new file size
        -:  300: * copy: number of bytes to copy if repacking required
        -:  301: *
        -:  302: * returns: offset of first byte repacked if repack occurred, else -1
        -:  303: */
       78:  304:int64_t resize_file_helper(file_t* file, size_t length, size_t copy, filesys_t* fs) {
       78:  305:	int64_t hash_offset = -1;
       78:  306:	int64_t old_length = file->length;
        -:  307:
        -:  308:	// Find suitable space in file_data if length increased
       78:  309:	if (length > old_length) {
       72:  310:		int64_t old_offset = file->offset;
       72:  311:		file_t* next_non_zero_file = NULL;
        -:  312:
        -:  313:		// Expansion of zero size files
       72:  314:		if (old_offset >= MAX_FILE_DATA_LEN) {
        -:  315:			// Remove the file from the sorted offset list
        3:  316:			arr_remove(file->o_index, fs->o_list);
        -:  317:
        -:  318:			// Find first non-zero size file
        3:  319:			next_non_zero_file = find_next_nonzero_file(0, fs->o_list);
        -:  320:
        -:  321:			// Repack if first non-zero size file offset is not large enough
        4:  322:			if (next_non_zero_file != NULL &&
        1:  323:				next_non_zero_file->offset < length) {
        1:  324:				hash_offset = repack_helper(fs);
        1:  325:				update_file_offset(fs->used, file);
        -:  326:
        -:  327:			// Otherwise, update file offset to 0
        -:  328:			} else {
        2:  329:				update_file_offset(0, file);
        -:  330:			}
        -:  331:
        3:  332:			update_dir_offset(file, fs);
        -:  333:
        -:  334:			// Re-insert file into sorted offset list
        3:  335:			arr_sorted_insert(file, fs->o_list);
        -:  336:			
        -:  337:		// Expansion of non-zero size files
        -:  338:		} else {
        -:  339:			// Find next non-zero size file
       69:  340:			next_non_zero_file =
       69:  341:					find_next_nonzero_file(file->o_index + 1, fs->o_list);
        -:  342:
       69:  343:			int repack_required = 0;
       69:  344:			if (next_non_zero_file != NULL) {
        -:  345:				// Repack if insufficient space between files
        2:  346:				repack_required =
        2:  347:						next_non_zero_file->offset - file->offset < length;
        -:  348:			} else {
        -:  349:				// Repack if insufficient space from end of file_data
       67:  350:				repack_required =
       67:  351:						fs->file_data_len - file->offset < length;
        -:  352:			}
        -:  353:
       69:  354:			if (repack_required) {
        -:  355:				// Copy required data into a buffer
        3:  356:				uint8_t* temp = salloc(sizeof(*temp) * copy);
        3:  357:				memcpy(temp, fs->file + file->offset, copy);
        -:  358:				
        -:  359:				// Remove file from sorted offset list
        3:  360:				arr_remove(file->o_index, fs->o_list);
        -:  361:
        -:  362:				// Repack and write buffer contents to the end of file_data
        3:  363:				hash_offset = repack_helper(fs);
        3:  364:				memcpy(fs->file + fs->used - old_length, temp, copy);
        3:  365:				free(temp);
        -:  366:				
        3:  367:				update_file_offset(fs->used - old_length, file);
        3:  368:				update_dir_offset(file, fs);
        -:  369:
        -:  370:				// Re-insert file into sorted offset list
        3:  371:				arr_sorted_insert(file, fs->o_list);
        -:  372:			}
        -:  373:		}
        -:  374:	}
        -:  375:	
        -:  376:	// Update file and dir_table if length changed
       78:  377:	if (length != old_length) {
       78:  378:		update_file_length(length, file);
       78:  379:		update_dir_length(file, fs);
        -:  380:
       78:  381:		fs->used += length - old_length;
        -:  382:	}
        -:  383:
       78:  384:	return hash_offset;
        -:  385:}
        -:  386:
       16:  387:int resize_file(char * filename, size_t length, void * helper) {
       16:  388:    filesys_t* fs = (filesys_t*)helper;
       16:  389:	LOCK(&fs->lock);
        -:  390:	
        -:  391:	// Return 1 if file does not exist
       16:  392:	file_t temp;
       16:  393:	update_file_name(filename, &temp);
       16:  394:	file_t* f = arr_get_by_key(&temp, fs->n_list);
       16:  395:	if (f == NULL) {
        1:  396:		UNLOCK(&fs->lock);
        1:  397:		return 1;
        -:  398:	}
        -:  399:	
        -:  400:	// Return 2 if insufficient space in file_data
       15:  401:	if (fs->used + (length - f->length) > fs->file_data_len) {
        1:  402:		UNLOCK(&fs->lock);
        1:  403:		return 2;
        -:  404:	}
        -:  405:	
        -:  406:	// Return 0 if new length is same as old length
       14:  407:	if (length == f->length) {
        1:  408:		UNLOCK(&fs->lock);
        1:  409:		return 0;
        -:  410:	}
        -:  411:	
       13:  412:	int64_t old_length = f->length;
       13:  413:	int64_t hash_offset = resize_file_helper(f, length, old_length, fs);
        -:  414:
       13:  415:	if (length > old_length) {
        7:  416:		write_null_byte(fs->file, f->offset + old_length, length - old_length);
        -:  417:
        7:  418:		if (hash_offset >= 0) {
        -:  419:			// Hash blocks modified by repack until end of file
        2:  420:			compute_hash_block_range(hash_offset,
        2:  421:					f->offset + length - hash_offset, fs);
        -:  422:		} else {
        -:  423:			// Only hash blocks containing the file
        5:  424:			compute_hash_block_range(f->offset + old_length,
        5:  425:					length - old_length, fs);
        -:  426:		}
        -:  427:	}
        -:  428:
       13:  429:	msync(fs->file, fs->file_data_len, MS_ASYNC);
       13:  430:	msync(fs->dir, fs->dir_table_len, MS_ASYNC);
       13:  431:	msync(fs->hash, fs->hash_data_len, MS_ASYNC);
        -:  432:
       13:  433:	UNLOCK(&fs->lock);
       13:  434:	return 0;
        -:  435:}
        -:  436:
        -:  437:/*
        -:  438: * Moves file data to new offset in file_data
        -:  439: *
        -:  440: * file: file_t of file being moved
        -:  441: * new_offset: new offset in file data to move file contents to
        -:  442: */
        9:  443:void repack_move(file_t* file, uint32_t new_offset, filesys_t* fs) {
        9:  444:	if (file->length > 0) {
        7:  445:		memmove(fs->file + new_offset, fs->file + file->offset, file->length);
        -:  446:	}
        -:  447:
        9:  448:	update_file_offset(new_offset, file);
        9:  449:	update_dir_offset(file, fs);
        9:  450:}
        -:  451:
        -:  452:/*
        -:  453: * Helper for repacking files, independent of the filesystem lock state
        -:  454: * The order of files is maintained during repack
        -:  455: *
        -:  456: * returns: offset of first byte modified if repack occurred, else -1
        -:  457: */
        8:  458:int64_t repack_helper(filesys_t* fs) {
        8:  459:	file_t** o_list = fs->o_list->list;
        8:  460:	int32_t size = fs->o_list->size;
        -:  461:	
        -:  462:	// Return if no files in filesystem
        8:  463:	if (fs->used <= 0 || size <= 0) {
        1:  464:		return -1;
        -:  465:	}
        -:  466:	
        -:  467:	// Variable for tracking blocks to hash
        7:  468:	int64_t hash_offset = -1;
        -:  469:
        -:  470:
        -:  471:	// Ensure first file at offset 0
        7:  472:	uint64_t start_curr_file = o_list[0]->offset;
        7:  473:	uint64_t end_prev_file = 0;
        7:  474:	int is_zero_size = o_list[0]->length == 0;
        7:  475:	if (start_curr_file > 0) {
        4:  476:		repack_move(o_list[0], 0, fs);
        -:  477:
        4:  478:		if (!is_zero_size) {
        4:  479:			hash_offset = 0;
        -:  480:		}
        -:  481:	}
        -:  482:	
        -:  483:	// Iterate over sorted offset array and move data when necessary
       16:  484:	for (int32_t i = 1; i < size; ++i) {
       14:  485:		start_curr_file = o_list[i]->offset;
       14:  486:		end_prev_file = o_list[i - 1]->offset + o_list[i - 1]->length;
       14:  487:		is_zero_size = o_list[i]->length == 0;
        -:  488:
        -:  489:		// Break if newly created zero size files encountered
       14:  490:		if (start_curr_file >= MAX_FILE_DATA_LEN) {
        5:  491:			break;
        -:  492:		}
        -:  493:
        9:  494:		if (start_curr_file > end_prev_file) {
        5:  495:			repack_move(o_list[i], end_prev_file, fs);
        -:  496:			
        5:  497:			if (hash_offset < 0 && !is_zero_size) {
        2:  498:				hash_offset = o_list[i]->offset;
        -:  499:			}
        -:  500:		}
        -:  501:	}
        -:  502:	
        7:  503:	return hash_offset;
        -:  504:}
        -:  505:
        1:  506:void repack(void * helper) {
        1:  507:    filesys_t* fs = (filesys_t*)helper;
        1:  508:	LOCK(&fs->lock);
        -:  509:	
        1:  510:	int64_t hash_offset = repack_helper(fs);
        -:  511:	
        -:  512:	// Hash blocked moved during repack
        1:  513:	if (hash_offset >= 0) {
        1:  514:		compute_hash_block_range(hash_offset, fs->used - hash_offset, fs);
        -:  515:	}
        -:  516:	
        1:  517:	msync(fs->file, fs->file_data_len, MS_ASYNC);
        1:  518:	msync(fs->dir, fs->dir_table_len, MS_ASYNC);
        1:  519:	msync(fs->hash, fs->hash_data_len, MS_ASYNC);
        -:  520:	
        1:  521:	UNLOCK(&fs->lock);
        1:  522:}
        -:  523:
        7:  524:int delete_file(char * filename, void * helper) {
        7:  525:    filesys_t* fs = (filesys_t*)helper;	
        7:  526:	LOCK(&fs->lock);
        -:  527:		
        -:  528:	// Return 1 if file does not exist
        7:  529:	file_t temp;
        7:  530:	update_file_name(filename, &temp);
        7:  531:	file_t* f = arr_get_by_key(&temp, fs->n_list);
        7:  532:	if (f == NULL) {
        1:  533:		UNLOCK(&fs->lock);
        1:  534:		return 1;
        -:  535:	}
        -:  536:	
        6:  537:	fs->used -= f->length;
        6:  538:	fs->index[f->index] = 0;
        6:  539:	--fs->index_count;
        -:  540:
        -:  541:	// Remove from arrays using indices
        6:  542:	arr_remove(f->o_index, fs->o_list);
        6:  543:	arr_remove(f->n_index, fs->n_list);
        -:  544:	
        -:  545:	// Write null byte in dir_table name field
        6:  546:	write_null_byte(fs->dir, f->index * META_LEN, 1);
        -:  547:	
        6:  548:	free_file(f);
        -:  549:	
        6:  550:	msync(fs->dir, fs->dir_table_len, MS_ASYNC);
        -:  551:	
        6:  552:	UNLOCK(&fs->lock);
        6:  553:	return 0;
        -:  554:}
        -:  555:
        5:  556:int rename_file(char * oldname, char * newname, void * helper) {
        5:  557:    filesys_t* fs = (filesys_t*)helper;
        5:  558:	LOCK(&fs->lock);
        -:  559:	
        5:  560:	file_t temp;
        5:  561:	update_file_name(oldname, &temp);
        5:  562:	file_t* f = arr_get_by_key(&temp, fs->n_list);
        -:  563:
        -:  564:	// Return 0 if names are the same and oldname file exists
        5:  565:	if (f != NULL && strcmp(oldname, newname) == 0) {
        1:  566:		UNLOCK(&fs->lock);
        1:  567:		return 0;
        -:  568:	}
        -:  569:
        -:  570:	// Return 1 if oldname file does not exist or newname file already exists
        4:  571:	update_file_name(newname, &temp);
        4:  572:	if (f == NULL || arr_get_by_key(&temp, fs->n_list) != NULL) {
        2:  573:		UNLOCK(&fs->lock);
        2:  574:		return 1;
        -:  575:	}
        -:  576:	
        2:  577:	update_file_name(newname, f);
        2:  578:	update_dir_name(f, fs);
        -:  579:	
        2:  580:	msync(fs->dir, fs->dir_table_len, MS_ASYNC);
        -:  581:	
        2:  582:	UNLOCK(&fs->lock);
        2:  583:	return 0;
        -:  584:}
        -:  585:
        6:  586:int read_file(char * filename, size_t offset, size_t count, void * buf, void * helper) {
        6:  587:	filesys_t* fs = (filesys_t*)helper;
        -:  588:
        -:  589:	// Filesystem mutex locked in read_file to ensure integrity of buffer
        -:  590:	// during parallel reads to the same buffer
        6:  591:	LOCK(&fs->lock);
        -:  592:	
        -:  593:	// Return 1 if file does not exist
        6:  594:	file_t temp;
        6:  595:	update_file_name(filename, &temp);
        6:  596:	file_t* f = arr_get_by_key(&temp, fs->n_list);
        6:  597:	if (f == NULL) {
        1:  598:		UNLOCK(&fs->lock);
        1:  599:		return 1;
        -:  600:	}
        -:  601:	
        -:  602:	// Return 2 if invalid offset and count for given file
        5:  603:	if (offset + count > f->length) {
        1:  604:		UNLOCK(&fs->lock);
        1:  605:		return 2;
        -:  606:	}
        -:  607:	
        -:  608:	// Return 3 if invalid hashes
        4:  609:	if (verify_hash_range(f->offset + offset, count, fs) != 0) {
        1:  610:		UNLOCK(&fs->lock);
        1:  611:		return 3;
        -:  612:	}
        -:  613:	
        -:  614:	// Return 0 if no bytes to read
        3:  615:	if (count == 0) {
        1:  616:		UNLOCK(&fs->lock);
        1:  617:		return 0;
        -:  618:	}
        -:  619:	
        2:  620:	memcpy(buf, fs->file + f->offset + offset, count);
        -:  621:	
        2:  622:	UNLOCK(&fs->lock);
        2:  623:	return 0;
        -:  624:}
        -:  625:
       71:  626:int write_file(char * filename, size_t offset, size_t count, void * buf, void * helper) {
       71:  627:    filesys_t* fs = (filesys_t*)helper;
       71:  628:	LOCK(&fs->lock);
        -:  629:	
        -:  630:	// Return 1 if file does not exist
       71:  631:	file_t temp;
       71:  632:	update_file_name(filename, &temp);
       71:  633:	file_t* f = arr_get_by_key(&temp, fs->n_list);
       71:  634:	if (f == NULL) {
        1:  635:		UNLOCK(&fs->lock);
        1:  636:		return 1;
        -:  637:	}
        -:  638:	
        -:  639:	// Return 2 if offset is invalid
       70:  640:	if (offset > f->length) {
        1:  641:		UNLOCK(&fs->lock);
        1:  642:		return 2;
        -:  643:	}
        -:  644:	
        -:  645:	// Return 3 if insufficient space in file_data
       69:  646:	if (fs->used + offset + count - f->length > fs->file_data_len) {
        1:  647:		UNLOCK(&fs->lock);
        1:  648:		return 3;
        -:  649:	}
        -:  650:	
        -:  651:	// Return 0 if no bytes to write
       68:  652:	if (count == 0) {
        1:  653:		UNLOCK(&fs->lock);
        1:  654:		return 0;
        -:  655:	}
        -:  656:	
        -:  657:	// Resize if write exceeds bounds of file
       67:  658:	int32_t hash_offset = -1;
       67:  659:	if (offset + count > f->length) {
       65:  660:		hash_offset = resize_file_helper(f, offset + count, offset, fs);
        -:  661:	}
        -:  662:	
       67:  663:	memcpy(fs->file + f->offset + offset, buf, count);
        -:  664:	
       67:  665:	if (hash_offset >= 0) {
        -:  666:		// Hash from first repacked byte to end of used file_data
        1:  667:		compute_hash_block_range(hash_offset, fs->used - hash_offset, fs);
        -:  668:	} else {
        -:  669:		// Only hash the bytes modified
       66:  670:		compute_hash_block_range(f->offset + offset, count, fs);
        -:  671:	}
        -:  672:	
       67:  673:	msync(fs->file, fs->file_data_len, MS_ASYNC);
       67:  674:	msync(fs->dir, fs->dir_table_len, MS_ASYNC);
       67:  675:	msync(fs->hash, fs->hash_data_len, MS_ASYNC);
        -:  676:	
       67:  677:	UNLOCK(&fs->lock);
       67:  678:	return 0;
        -:  679:}
        -:  680:
        4:  681:ssize_t file_size(char * filename, void * helper) {
        4:  682:    filesys_t* fs = (filesys_t*)helper;
        4:  683:	LOCK(&fs->lock);
        -:  684:	
        -:  685:	// Return -1 if file does not exist
        4:  686:	file_t temp;
        4:  687:	update_file_name(filename, &temp);
        4:  688:	file_t* f = arr_get_by_key(&temp, fs->n_list);
        4:  689:	if (f == NULL) {
        1:  690:		UNLOCK(&fs->lock);
        1:  691:		return -1;
        -:  692:	}
        -:  693:	
        -:  694:	// Return length of file
        3:  695:	UNLOCK(&fs->lock);
        3:  696:	return f->length;
        -:  697:}
        -:  698:
      417:  699:void fletcher(uint8_t * buf, size_t length, uint8_t * output) {
      417:  700:	assert(buf != NULL && output != NULL && "invalid args");
        -:  701:	
        -:  702:	// Casting buffer to uint32_t for reading
      417:  703:	uint32_t* buff = (uint32_t*)buf;
        -:  704:	
        -:  705:	// Calculate quotient and remainder for buff
      417:  706:	uint64_t size = length / 4;
      417:  707:	uint64_t rem = length % 4;
        -:  708:	
      417:  709:	uint64_t a = 0;
      417:  710:	uint64_t b = 0;
      417:  711:	uint64_t c = 0;
      417:  712:	uint64_t d = 0;
    11584:  713:	for (uint64_t i = 0; i < size; ++i) {
    11167:  714:		a = (a + buff[i]) % MAX_FILE_DATA_LEN_MINUS_ONE;
    11167:  715:		b = (b + a) % MAX_FILE_DATA_LEN_MINUS_ONE;
    11167:  716:		c = (c + b) % MAX_FILE_DATA_LEN_MINUS_ONE;
    11167:  717:		d = (d + c) % MAX_FILE_DATA_LEN_MINUS_ONE;
        -:  718:	}
        -:  719:	
        -:  720:	// Hash last unsigned integer if required
      417:  721:	if (rem != 0) {
        1:  722:		uint32_t last = 0; // Initialised to zero for null byte padding
        1:  723:		memcpy(&last, buff + size, sizeof(uint8_t) * rem);
        1:  724:		a = (a + last) % MAX_FILE_DATA_LEN_MINUS_ONE;
        1:  725:		b = (b + a) % MAX_FILE_DATA_LEN_MINUS_ONE;
        1:  726:		c = (c + b) % MAX_FILE_DATA_LEN_MINUS_ONE;
        1:  727:		d = (d + c) % MAX_FILE_DATA_LEN_MINUS_ONE;
        -:  728:	}
        -:  729:	
        -:  730:	// Copy result to output buffer at required offset
      417:  731:	memcpy(output, &a, sizeof(uint32_t));
      417:  732:	memcpy(output + HASH_OFFSET_B, &b, sizeof(uint32_t));
      417:  733:	memcpy(output + HASH_OFFSET_C, &c, sizeof(uint32_t));
      417:  734:	memcpy(output + HASH_OFFSET_D, &d, sizeof(uint32_t));
      417:  735:}
        -:  736:
        -:  737:/*
        -:  738: * Writes the hash for the node at n_index to address out
        -:  739: *
        -:  740: * n_index: index of node in hash tree
        -:  741: * hash_cat: address of stack array used for concatenating hashes
        -:  742: * out: address that output hash is written to
        -:  743: */
       16:  744:void hash_node(int32_t n_index, uint8_t* hash_cat, uint8_t* out, filesys_t* fs) {
        -:  745:	// If internal node, calculate hash of concatenated child hashes
       16:  746:	if (n_index < fs->leaf_offset) {
        9:  747:		memcpy(hash_cat, fs->hash + lc_index(n_index) * HASH_LEN, HASH_LEN);
        9:  748:		memcpy(hash_cat + HASH_LEN, fs->hash + rc_index(n_index) * HASH_LEN,
        -:  749:				HASH_LEN);
        9:  750:		fletcher(hash_cat, 2 * HASH_LEN, out);
        -:  751:		
        -:  752:	// Otherwise, calculate hash of file_data block for leaf node
        -:  753:	} else {
        7:  754:		fletcher(fs->file + (n_index - fs->leaf_offset) * BLOCK_LEN,
        -:  755:				BLOCK_LEN, out);
        -:  756:	}
       16:  757:}
        -:  758:
        1:  759:void compute_hash_tree(void * helper) {
        1:  760:	filesys_t* fs = (filesys_t*)helper;
        1:  761:	LOCK(&fs->lock);
        -:  762:	
        -:  763:	// Variables for bottom-to-top level traversal of hash tree
        1:  764:	uint8_t* hash_addr = fs->hash;
        1:  765:	int32_t n_index = fs->leaf_offset;
        1:  766:	int32_t n_count = 0;
        1:  767:	int32_t nodes_in_level = n_index + 1;
        1:  768:	uint8_t hash_cat[2 * HASH_LEN];
        -:  769:
        9:  770:	while (nodes_in_level > 0) {
        -:  771:		// Write hash of current node to hash_data
        7:  772:		hash_node(n_index, hash_cat, hash_addr + n_index * HASH_LEN, fs);
        -:  773:		
        7:  774:		if (++n_count < nodes_in_level) {
        4:  775:			++n_index;
        -:  776:		} else {
        -:  777:			// Move to next level once current level is completed
        3:  778:			nodes_in_level /= 2;
        3:  779:			n_index = nodes_in_level - 1;
        3:  780:			n_count = 0;
        -:  781:		}
        -:  782:	}
        -:  783:
        1:  784:	msync(fs->hash, fs->hash_data_len, MS_ASYNC);
        -:  785:
        1:  786:	UNLOCK(&fs->lock);
        1:  787:}
        -:  788:
        -:  789:/*
        -:  790: * Helper for updating hash for block at offset specified, independent of
        -:  791: * filesystem lock state
        -:  792: *
        -:  793: * offset: index of block in file_data
        -:  794: */
      133:  795:void compute_hash_block_helper(size_t block_offset, filesys_t* fs) {
        -:  796:	// Calculate the index of the leaf node for the block
      133:  797:	int32_t n_index = fs->leaf_offset + block_offset;
        -:  798:	
        -:  799:	// Update the leaf node hash
      133:  800:	fletcher(fs->file + block_offset * BLOCK_LEN, BLOCK_LEN,
      133:  801:			fs->hash + n_index * HASH_LEN);
        -:  802:	
        -:  803:	// Update parent node hashes all the way to the root node
      133:  804:	uint8_t hash_cat[2 * HASH_LEN];
      532:  805:	while ((n_index = p_index(n_index)) >= 0) {
      266:  806:		memcpy(hash_cat, fs->hash + lc_index(n_index) * HASH_LEN, HASH_LEN);
      266:  807:		memcpy(hash_cat + HASH_LEN, fs->hash + rc_index(n_index) * HASH_LEN,
        -:  808:				HASH_LEN);
        -:  809:		
      266:  810:		fletcher(hash_cat, 2 * HASH_LEN, fs->hash + n_index * HASH_LEN);
        -:  811:	}
      133:  812:}
        -:  813:
        -:  814:/*
        -:  815: * Update hashes for file_data blocks in the range specified
        -:  816: *
        -:  817: * offset: file_data offset of first byte modified
        -:  818: * length: number of adjacent bytes modified
        -:  819: */
      118:  820:void compute_hash_block_range(int64_t offset, int64_t length, filesys_t* fs) {
        -:  821:	// Return if length is 0
      118:  822:	if (length <= 0) {
        1:  823:		return;
        -:  824:	}
        -:  825:
      117:  826:	assert(fs != NULL && "invalid args");
        -:  827:	
        -:  828:	// Determine first and last block modified
      117:  829:	int64_t first_block = offset / BLOCK_LEN;
      117:  830:	int64_t last_block = (offset + length - 1) / BLOCK_LEN;
        -:  831:	
        -:  832:	// Update hash tree for each block modified
      249:  833:	for (int64_t i = first_block; i <= last_block; ++i) {
      132:  834:		compute_hash_block_helper(i, fs);
        -:  835:	}
        -:  836:}
        -:  837:
        1:  838:void compute_hash_block(size_t block_offset, void * helper) {
        1:  839:	filesys_t* fs = (filesys_t*)helper;
        1:  840:	LOCK(&fs->lock);
        -:  841:	
        1:  842:	compute_hash_block_helper(block_offset, fs);
        -:  843:	
        1:  844:	msync(fs->hash, fs->hash_data_len, MS_ASYNC);
        -:  845:	
        1:  846:	UNLOCK(&fs->lock);
        1:  847:}
        -:  848:
        -:  849:/*
        -:  850: * Compare hashes for blocks in the range specified
        -:  851: *
        -:  852: * offset: offset in file_data to start verification
        -:  853: * length: number of bytes to verify
        -:  854: *
        -:  855: * return: 0 on success, -1 on failed verification
        -:  856: */
        4:  857:int32_t verify_hash_range(int64_t offset, int64_t length, filesys_t* fs) {
        -:  858:	// Return 0 if length is 0
        4:  859:	if (length <= 0) {
        1:  860:		return 0;
        -:  861:	}
        -:  862:
        3:  863:	assert(fs != NULL && "invalid args");
        -:  864:	
        -:  865:	// Determine first and last block to verify
        3:  866:	int64_t first_block = offset / BLOCK_LEN;
        3:  867:	int64_t last_block = (offset + length - 1) / BLOCK_LEN;
        -:  868:	
        -:  869:	// Verify hashes for each block
        -:  870:	int32_t n_index;
        3:  871:	uint8_t curr_hash[HASH_LEN];
        3:  872:	uint8_t hash_cat[2 * HASH_LEN];
        5:  873:	for (int32_t i = first_block; i <= last_block; ++i) {
        -:  874:		// Get leaf node index for block
        3:  875:		n_index = fs->leaf_offset + i;
        -:  876:		
        -:  877:		// Compare hashes from leaf to root
       14:  878:		while (n_index >= 0) {
        9:  879:			hash_node(n_index, hash_cat, curr_hash, fs);
        -:  880:
        -:  881:			// Return 1 if verification failed
        9:  882:			if (memcmp(curr_hash,
        9:  883:					fs->hash + n_index * HASH_LEN, HASH_LEN) != 0) {
        1:  884:				return 1;
        -:  885:			}
        8:  886:			n_index = p_index(n_index);
        -:  887:		}
        -:  888:	}
        -:  889:	
        2:  890:	return 0;
        -:  891:}		
