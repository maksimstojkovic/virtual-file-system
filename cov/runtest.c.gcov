        -:    0:Source:runtest.c
        -:    0:Programs:4
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <sys/types.h>
        -:    5:#include <sys/stat.h>
        -:    6:#include <fcntl.h>
        -:    7:#include <unistd.h>
        -:    8:#include <sys/mman.h>
        -:    9:#include <assert.h>
        -:   10:
        -:   11:#include "structs.h"
        -:   12:#include "helper.h"
        -:   13:#include "arr.h"
        -:   14:#include "myfilesystem.h"
        -:   15:
        -:   16:// Macro for running test functions
        -:   17:#define TEST(x) test(x, #x)
        -:   18:
        -:   19:// Defined file length values
        -:   20:#define F1_LEN (1024) // file_data length
        -:   21:#define F2_LEN (720) // dir_table length
        -:   22:#define F3_LEN (112) // hash_data length
        -:   23:
        -:   24:// Static filesystem filenames and file descriptors
        -:   25:static char* f1 = "file_data.bin";
        -:   26:static char* f2 = "directory_table.bin";
        -:   27:static char* f3 = "hash_data.bin";
        -:   28:static int file_fd;
        -:   29:static int dir_fd;
        -:   30:static int hash_fd;
        -:   31:
        -:   32:static int error_count;
        -:   33:
        -:   34:/*
        -:   35: * Filesystem Test Functions
        -:   36: *
        -:   37: * This file contains a series of tests for methods listed in the filesystem
        -:   38: * specification, in addition to helper methods and data structures
        -:   39: * implemented. The primary focus of these tests was to ensure methods produced
        -:   40: * the correct output, whilst maximising code coverage through edge case
        -:   41: * testing with zero size files. During testing, HTML coverage reports were
        -:   42: * generated using the "lcov.sh" script (HTML reports available in
        -:   43: * "cov/cov-html/index.html"). However, since lcov is not available on Ed,
        -:   44: * "gcov.sh" can also be used to output results from gcov.
        -:   45: */
        -:   46:
        -:   47:/*
        -:   48: * Helper Functions
        -:   49: */
        -:   50:
        -:   51:/*
        -:   52: * Runs filesystem tests, prints return values and updates
        -:   53: * the global error_count
        -:   54: */
       32:   55:void test(int (*test_function) (), char * function_name) {
        -:   56:	static long test_count = 1;
       32:   57:	int ret = test_function();
       32:   58:	if (ret == 0) {
       31:   59:		printf("%3ld. Passed %s\n", test_count, function_name);
        -:   60:	} else {
        1:   61:		printf("%3ld. Failed %s returned %d\n", test_count, function_name, ret);
        1:   62:		++error_count;
        -:   63:	}
       32:   64:	++test_count;
       32:   65:}
        -:   66:
        -:   67:/*
        -:   68: * Writes null bytes to file_data, dir_table and hash_data
        -:   69: * Used at the beginning of tests to ensure filesystem is reset
        -:   70: */
       31:   71:void gen_blank_files() {
       31:   72:	pwrite_null_byte(file_fd, 0, F1_LEN);
       31:   73:	pwrite_null_byte(dir_fd, 0, F2_LEN);
       31:   74:	pwrite_null_byte(hash_fd, 0, F3_LEN);
       31:   75:}
        -:   76:
        -:   77:/*
        -:   78: * Filesystem Test Functions
        -:   79: */
        -:   80:
        -:   81:// Tests success
        1:   82:int success() {
        1:   83:    return 0;
        -:   84:}
        -:   85:
        -:   86:// Tests failure
        1:   87:int failure() {
        1:   88:	--error_count; // Decrement as failure is expected
        1:   89:    return 1;
        -:   90:}
        -:   91:
        -:   92:// Tests myfilesystem helpers for invalid arguments
        1:   93:int test_helper_error_handling() {
        1:   94:	gen_blank_files();
        1:   95:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:   96:
        -:   97:	// Pass empty filesystem to repack_helper
        1:   98:	assert(repack_helper(fs) == -1 && "repack_helper failed");
        -:   99:
        -:  100:	// Pass count == 0 to null byte writing helpers
        1:  101:	assert(write_null_byte(NULL, 0, 0) == 0 &&
        -:  102:	       pwrite_null_byte(file_fd, 0, 0) == 0 &&
        -:  103:	       "null byte helpers should return 0 bytes written");
        -:  104:
        -:  105:	// Pass length == 0 to compute_hash_block_range
        -:  106:	// Helper should return without assertion failure
        1:  107:	compute_hash_block_range(0, 0, NULL);
        -:  108:
        1:  109:	close_fs(fs);
        1:  110:	return 0;
        -:  111:}
        -:  112:
        -:  113:// Tests initialising and freeing arrays for memory leaks
        1:  114:int test_array_empty() {
        1:  115:	filesys_t* fs = salloc(sizeof(*fs));
        1:  116:	arr_t* o_list = arr_init(F2_LEN / META_LEN, OFFSET, fs);
        1:  117:	arr_t* n_list = arr_init(F2_LEN / META_LEN, NAME, fs);
        1:  118:	free_arr(o_list);
        1:  119:	free_arr(n_list);
        1:  120:	free(fs);
        1:  121:	return 0;
        -:  122:}
        -:  123:
        -:  124:// Tests sorted array insertion
        1:  125:int test_array_insert() {
        1:  126:	gen_blank_files();
        1:  127:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  128:
        -:  129:	// Normal and zero size files
        1:  130:	file_t* f[4];
        1:  131:	f[0] = file_init("zero.txt", new_file_offset(0, NULL, fs), 0, 3);
        1:  132:	f[1] = file_init("test3.txt", 5, 10, 0);
        1:  133:	f[2] = file_init("test2.txt", 0, 5, 2);
        1:  134:	f[3] = file_init("test1.txt", 15, 10, 1);
        -:  135:
        -:  136:	// Expected order in offset and name arrays
        1:  137:	file_t* o_expect[4] = {f[2], f[1], f[3], f[0]};
        1:  138:	file_t* n_expect[4] = {f[3], f[2], f[1], f[0]};
        -:  139:
        -:  140:	// Insert elements into arrays
        5:  141:	for (int i = 0; i < 4; ++i) {
        4:  142:		arr_sorted_insert(f[i], fs->o_list);
        4:  143:		arr_sorted_insert(f[i], fs->n_list);
        -:  144:	}
        -:  145:
        -:  146:	// Try inserting duplicate file
        1:  147:	assert(arr_sorted_insert(f[3], fs->o_list) == -1 &&
        -:  148:	       arr_sorted_insert(f[3], fs->n_list) == -1 &&
        -:  149:	       "duplicate insertion should fail");
        -:  150:
        -:  151:	// Compare offset and name lists with expected
        5:  152:	for (int i = 0; i < 4; ++i) {
        4:  153:		assert(fs->o_list->list[i] == o_expect[i] &&
        -:  154:		       "offset list insertion order incorrect");
        4:  155:		assert(fs->n_list->list[i] == n_expect[i] &&
        -:  156:			   "name list insertion order incorrect");
        -:  157:	}
        -:  158:
        1:  159:	close_fs(fs);
        1:  160:	return 0;
        -:  161:}
        -:  162:
        -:  163:// Tests retrieval of array elements by key
        1:  164:int test_array_get() {
        1:  165:	gen_blank_files();
        1:  166:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  167:
        -:  168:	// Test zero size files and normal files
        -:  169:	// Arbitrary ordering used for dir_table indices
        -:  170:	// Majority of zero size files used to test binary search handling
        1:  171:	file_t* f[7];
        1:  172:	f[0] = file_init("zero4.txt", new_file_offset(0, NULL, fs), 0, 3);
        1:  173:	f[1] = file_init("zero3.txt", new_file_offset(0, NULL, fs), 0, 4);
        1:  174:	f[2] = file_init("zero2.txt", new_file_offset(0, NULL, fs), 0, 6);
        1:  175:	f[3] = file_init("zero1.txt", new_file_offset(0, NULL, fs), 0, 5);
        1:  176:	f[4] = file_init("f3.txt", 5, 10, 0);
        1:  177:	f[5] = file_init("f2.txt", 0, 5, 2);
        1:  178:	f[6] = file_init("f1.txt", 15, 10, 1);
        -:  179:
        1:  180:	file_t key[5];
        1:  181:	update_file_offset(5, &key[0]);
        1:  182:	update_file_offset(20, &key[1]);
        1:  183:	update_file_offset(MAX_FILE_DATA_LEN, &key[2]);
        1:  184:	update_file_name("zero1.txt", &key[3]);
        1:  185:	update_file_name("nothing", &key[4]);
        -:  186:
        -:  187:	// Insert elements into arrays
        8:  188:	for (int i = 0; i < 7; ++i) {
        7:  189:		arr_sorted_insert(f[i], fs->o_list);
        7:  190:		arr_sorted_insert(f[i], fs->n_list);
        -:  191:	}
        -:  192:
        -:  193:	// Successful get operations
        1:  194:	assert(arr_get_by_key(&key[0], fs->o_list) == f[4] &&
        -:  195:		   arr_get_by_key(&key[3], fs->n_list) == f[3] &&
        -:  196:		   "incorrect file_t* retrieved");
        -:  197:
        -:  198:	// File not found operations
        1:  199:	assert(arr_get_by_key(&key[1], fs->o_list) == NULL &&
        -:  200:		   arr_get_by_key(&key[2], fs->o_list) == NULL &&
        -:  201:		   arr_get_by_key(&key[4], fs->n_list) == NULL &&
        -:  202:		   "file should not be found");
        -:  203:
        -:  204:	// Test offset key value comparison for zero size files
        1:  205:	file_t file_a;
        -:  206:	file_t* file_b;
        1:  207:	update_file_offset(MAX_FILE_DATA_LEN, &file_a);
        1:  208:	file_b = file_init("offset.txt", new_file_offset(0, NULL, fs), 0, 7);
        -:  209:
        1:  210:	assert(cmp_key(&file_a, file_b, fs->o_list) == -1 &&
        -:  211:		   "newly created zero size file should redirect to lower indices");
        -:  212:
        1:  213:	update_file_offset(50, &file_a);
        1:  214:	update_file_offset(50, file_b);
        1:  215:	assert(cmp_key(&file_a, file_b, fs->o_list) == 1 &&
        -:  216:		   "resized zero size file should redirect to higher indices");
        -:  217:
        1:  218:	free(file_b);
        1:  219:	close_fs(fs);
        1:  220:	return 0;
        -:  221:}
        -:  222:
        -:  223:// Tests removal of array elements by key
        1:  224:int test_array_remove() {
        1:  225:	gen_blank_files();
        1:  226:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        1:  227:	file_t* f[5];
        1:  228:	f[0] = file_init("test3.txt", 5, 10, 0);
        1:  229:	f[1] = file_init("zero2.txt", new_file_offset(0, NULL, fs), 0, 3);
        1:  230:	f[2] = file_init("zero1.txt", new_file_offset(0, NULL, fs), 0, 4);
        1:  231:	f[3] = file_init("test2.txt", 0, 5, 2);
        1:  232:	f[4] = file_init("test1.txt", 15, 10, 1);
        -:  233:
        1:  234:	file_t key[5];
        1:  235:	update_file_offset(5, &key[0]);
        1:  236:	update_file_offset(20, &key[1]);
        1:  237:	update_file_offset(MAX_FILE_DATA_LEN, &key[2]);
        1:  238:	update_file_name("zero1.txt", &key[3]);
        1:  239:	update_file_name("nothing", &key[4]);
        -:  240:
        1:  241:	file_t* o_expect[3] = {f[3], f[4], f[1]};
        1:  242:	file_t* n_expect[3] = {f[4], f[3], f[1]};
        -:  243:
        -:  244:	// Insert elements into arrays
        6:  245:	for (int i = 0; i < 5; ++i) {
        5:  246:		arr_sorted_insert(f[i], fs->o_list);
        5:  247:		arr_sorted_insert(f[i], fs->n_list);
        -:  248:	}
        -:  249:
        -:  250:	// Remove files using key file_t structs
        1:  251:	file_t* norm_f = arr_remove_by_key(&key[0], fs->o_list);
        1:  252:	file_t* zero_f = arr_remove_by_key(&key[3], fs->n_list);
        1:  253:	assert(norm_f == f[0] && zero_f == f[2] && "removed incorrect files");
        -:  254:
        -:  255:	// Remove corresponding entry in opposing list
        1:  256:	assert(arr_remove(norm_f->n_index, fs->n_list) == norm_f &&
        -:  257:		   arr_remove(zero_f->o_index, fs->o_list) == zero_f &&
        -:  258:		   "failed to remove opposing list entry");
        -:  259:
        -:  260:	// Attempt to remove files with invalid keys
        1:  261:	assert(arr_remove_by_key(&key[1], fs->o_list) == NULL &&
        -:  262:		   arr_remove_by_key(&key[2], fs->o_list) == NULL &&
        -:  263:		   arr_remove_by_key(&key[4], fs->n_list) == NULL &&
        -:  264:		   "invalid keys should return NULL");
        -:  265:
        -:  266:	// Compare offset and name lists with expected
        4:  267:	for (int i = 0; i < 3; ++i) {
        3:  268:		assert(fs->o_list->list[i] == o_expect[i] &&
        -:  269:			   "incorrect offset order after removal");
        3:  270:		assert(fs->n_list->list[i] == n_expect[i] &&
        -:  271:			   "incorrect name order after removal");
        -:  272:	}
        -:  273:
        1:  274:	free(norm_f);
        1:  275:	free(zero_f);
        1:  276:	close_fs(fs);
        1:  277:	return 0;
        -:  278:}
        -:  279:
        -:  280:// Tests initialising and closing filesystem for memory leaks
        1:  281:int test_no_operation() {
        1:  282:	gen_blank_files();
        1:  283:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        1:  284:	close_fs(fs);
        1:  285:	return 0;
        -:  286:}
        -:  287:
        -:  288:// Tests init_fs and close_fs for invalid argument handling and reading in
        -:  289:// zero size files on initialisation
        1:  290:int test_init_close_error_handling() {
        -:  291:	// Pass NULL to close_fs
        1:  292:	close_fs(NULL);
        -:  293:
        -:  294:	//Create blank filesystem files and create a file of 0 length at offset 0
        1:  295:	gen_blank_files();
        1:  296:	char* name = "zero_size_file";
        1:  297:	pwrite(dir_fd, name, strlen(name), 0);
        1:  298:	fsync(dir_fd);
        -:  299:
        1:  300:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  301:
        -:  302:	// Read offset and length from dir_table
        1:  303:	file_t dir_table_file;
        1:  304:	pread(dir_fd, &dir_table_file.offset, sizeof(uint32_t), NAME_LEN);
        1:  305:	pread(dir_fd, &dir_table_file.length, sizeof(uint32_t),
        -:  306:			NAME_LEN + OFFSET_LEN);
        -:  307:
        -:  308:	// Retrieve file from internal filesystem structure
        1:  309:	file_t key;
        1:  310:	update_file_name(name, &key);
        1:  311:	file_t* internal_file = arr_get_by_key(&key, fs->n_list);
        -:  312:
        -:  313:	// Casting used to compare only the first 4 bytes of uint64_t offset
        1:  314:	assert((uint32_t)(dir_table_file.offset) == 0 &&
        -:  315:	       dir_table_file.length == 0 &&
        -:  316:		   internal_file->offset == MAX_FILE_DATA_LEN &&
        -:  317:		   internal_file->length == 0 && "failed to read zero size file");
        -:  318:
        1:  319:	close_fs(fs);
        1:  320:	return 0;
        -:  321:}
        -:  322:
        -:  323:// Tests create_file with repacking
        1:  324:int test_create_file_success() {
        1:  325:	gen_blank_files();
        1:  326:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  327:
        1:  328:	assert(!create_file("zero1.txt", 0, fs) &&
        -:  329:	       !create_file("zero2.txt", 0, fs) &&
        -:  330:	       !create_file("test1.txt", 50, fs) &&
        -:  331:		   !create_file("test2.txt", 100, fs) &&
        -:  332:		   !create_file("test3.txt", 800, fs) &&
        -:  333:		   !create_file("zero3.txt", 0, fs) &&
        -:  334:		   "create failed");
        -:  335:
        -:  336:	// delete_file to create a gap in file_data
        1:  337:	assert(!delete_file("test2.txt", fs) && "delete failed");
        -:  338:
        -:  339:	// create_file in gap created
        1:  340:	assert(!create_file("test4.txt", 20, fs) &&
        -:  341:	       "create in contiguous block failed");
        -:  342:
        -:  343:	// Test create_file offset finder repack with NULL argument
        1:  344:	assert(new_file_offset(150, NULL, fs) == 870 &&
        -:  345:	       "offset finder unexpectedly failed");
        -:  346:
        -:  347:	// Create and delete files such that a repack is required for test5.txt
        1:  348:	assert(!create_file("block.txt", 100, fs) &&
        -:  349:	       !create_file("byte.txt", 1, fs) &&
        -:  350:	       !delete_file("block.txt", fs) && "creating block gap failed");
        -:  351:
        -:  352:	// Create file with repack
        1:  353:	assert(!create_file("test5.txt", 150, fs) && "create with repack failed");
        -:  354:
        1:  355:	close_fs(fs);
        1:  356:	return 0;
        -:  357:}
        -:  358:
        -:  359:// Attempts to create a duplicate file with the same name, and tests
        -:  360:// reading in existing files within init_fs
        1:  361:int test_create_file_exists() {
        1:  362:	gen_blank_files();
        1:  363:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  364:
        1:  365:	assert(!create_file("document.txt", 50, fs) && "create failed");
        -:  366:
        1:  367:	assert(create_file("document.txt", 20, fs) == 1 &&
        -:  368:	       "creating duplicate should fail");
        -:  369:
        -:  370:	// Close and re-initialise file system, before attempting to
        -:  371:	// create duplicate
        1:  372:	close_fs(fs);
        1:  373:	fs = init_fs(f1, f2, f3, 1);
        -:  374:
        1:  375:	assert(create_file("document.txt", 20, fs) == 1 &&
        -:  376:		   "creating duplicate after re-initialising should fail");
        -:  377:
        1:  378:	close_fs(fs);
        1:  379:	return 0;
        -:  380:}
        -:  381:
        -:  382:// Tests behaviour of filesystem when file_data's length is exceeded,
        -:  383:// and when dir_table is completely filled with file entries
        1:  384:int test_create_file_no_space() {
        1:  385:	gen_blank_files();
        1:  386:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  387:
        1:  388:	assert(!create_file("test1.txt", 50, fs) && "create failed");
        -:  389:
        -:  390:	// Create file larger than file_data
        1:  391:	assert(create_file("test2.txt", 975, fs) == 2 &&
        -:  392:	       "creating file too large for file_data should fail");
        -:  393:
        1:  394:	assert(!create_file("test3.txt", 974, fs) &&
        -:  395:		   "max size create failed");
        -:  396:
        1:  397:	close_fs(fs);
        -:  398:
        -:  399:	// Check handling of full dir_table listing
        1:  400:	gen_blank_files();
        1:  401:	fs = init_fs(f1, f2, f3, 1);
        -:  402:
        -:  403:	// Pointer to static array for assigning different names to files
        1:  404:	char* names = "abcdefghij";
        -:  405:
       11:  406:	for (int i = 0; i < 10; ++i) {
        -:  407:		// Increment pointer after create file to change name of next file
       10:  408:		create_file(names++, 0, fs);
        -:  409:	}
        -:  410:
        1:  411:	assert(create_file("dir_table_overload.txt", 0, fs) == 2 &&
        -:  412:		   "dir_table should be full");
        -:  413:
        1:  414:	close_fs(fs);
        1:  415:	return 0;
        -:  416:}
        -:  417:
        -:  418:// Tests resizing files with repacking and compares dir_table
        -:  419:// values with expected values
        1:  420:int test_resize_file_success() {
        1:  421:	gen_blank_files();
        1:  422:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  423:
        1:  424:	assert(!create_file("test1.txt", 50, fs) &&
        -:  425:		   !create_file("test2.txt", 10, fs) &&
        -:  426:		   !create_file("zero1.txt", 0, fs) &&
        -:  427:		   !create_file("zero2.txt", 0, fs) &&
        -:  428:		   "create failed");
        -:  429:
        1:  430:	assert(!resize_file("test2.txt", 50, fs) && "resize failed");
        -:  431:
        -:  432:	// Resize to same size
        1:  433:	assert(!resize_file("test1.txt", 50, fs) && "resize to same size failed");
        -:  434:
        -:  435:	// Resize with repack
        1:  436:	assert(!resize_file("test1.txt", 100, fs) &&
        -:  437:		   !resize_file("test2.txt", 100, fs) && "resize repack failed");
        -:  438:
        -:  439:	// Resize to zero size file with offset != 0
        1:  440:	assert(!resize_file("test2.txt", 0, fs) &&
        -:  441:	       "resize to zero size non-zero offset failed");
        -:  442:
        -:  443:	// Max size resize
        1:  444:	assert(!resize_file("test1.txt", F1_LEN, fs) && // Does not repack
        -:  445:		   !resize_file("test1.txt", 0, fs) &&
        -:  446:		   !resize_file("zero1.txt", F1_LEN, fs) &&
        -:  447:		   "resize to file_data length failed");
        -:  448:
        -:  449:	// Check offset and length of files
        1:  450:	file_t f[3]; // file_t structs for test1.txt, text2.txt and zero1.txt
        1:  451:	msync(fs->dir, fs->dir_table_len, MS_SYNC); // Ensure dir_table is synced
        1:  452:	fsync(dir_fd);
        -:  453:
        -:  454:	// Read from dir_table
        1:  455:	pread(dir_fd, &f[0].offset, sizeof(uint32_t), NAME_LEN);
        1:  456:	pread(dir_fd, &f[0].length, sizeof(uint32_t), NAME_LEN + OFFSET_LEN);
        1:  457:	pread(dir_fd, &f[1].offset, sizeof(uint32_t), META_LEN + NAME_LEN);
        1:  458:	pread(dir_fd, &f[1].length, sizeof(uint32_t),
        -:  459:			META_LEN + NAME_LEN + OFFSET_LEN);
        1:  460:	pread(dir_fd, &f[2].offset, sizeof(uint32_t),
        -:  461:			2 * META_LEN + NAME_LEN);
        1:  462:	pread(dir_fd, &f[2].length, sizeof(uint32_t),
        -:  463:			2 * META_LEN + NAME_LEN + OFFSET_LEN);
        -:  464:
        -:  465:	// Compare dir_table values with expected
        -:  466:	// Casting used to compare only the first 4 bytes of uint64_t offset
        1:  467:	assert((uint32_t)f[0].offset == 0 && f[0].length == 0 &&
        -:  468:		   (uint32_t)f[1].offset == 100 && f[1].length == 0 &&
        -:  469:		   (uint32_t)f[2].offset == 0 && f[2].length == F1_LEN &&
        -:  470:		   "incorrect dir_table values");
        -:  471:
        -:  472:	// Resize files to create a gap such that zero2.txt requires
        -:  473:	// a repack on expansion
        1:  474:	assert(!resize_file("zero1.txt", 10, fs) &&
        -:  475:		   !resize_file("test1.txt", 50, fs) &&
        -:  476:		   !resize_file("zero1.txt", 0, fs) &&
        -:  477:		   !resize_file("zero2.txt", 20, fs) &&
        -:  478:		   "resize from zero size with repack failed");
        -:  479:
        -:  480:
        1:  481:	close_fs(fs);
        1:  482:	return 0;
        -:  483:}
        -:  484:
        -:  485:// Attempts to resize files that do not exist
        1:  486:int test_resize_file_does_not_exist() {
        1:  487:	gen_blank_files();
        1:  488:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  489:
        1:  490:	assert(!create_file("test1.txt", 50, fs) &&
        -:  491:		   !create_file("test2.txt", 10, fs) &&
        -:  492:		   "create failed");
        -:  493:
        1:  494:	assert(resize_file("test3.txt", 50, fs) == 1 &&
        -:  495:		   "file being resized does not exist");
        -:  496:
        1:  497:	close_fs(fs);
        1:  498:	return 0;
        -:  499:}
        -:  500:
        -:  501:// Attempts to resize files to a size larger than the filesystem
        1:  502:int test_resize_file_no_space() {
        1:  503:	gen_blank_files();
        1:  504:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  505:
        1:  506:	assert(!create_file("test1.txt", 50, fs) && "create failed");
        -:  507:
        -:  508:	// Resize to length larger than filesystem
        1:  509:	assert(resize_file("test1.txt", 1025, fs) == 2 &&
        -:  510:		   "resize larger than file_data should fail");
        -:  511:
        1:  512:	close_fs(fs);
        1:  513:	return 0;
        -:  514:}
        -:  515:
        -:  516:// Tests filesystem repack with zero size files appended
        1:  517:int test_repack_success() {
        1:  518:	gen_blank_files();
        1:  519:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  520:
        -:  521:	// Create and delete files to create gaps between files
        1:  522:	assert(!create_file("test1.txt", 50, fs) &&
        -:  523:		   !create_file("test2.txt", 10, fs) &&
        -:  524:		   !create_file("test3.txt", 20, fs) &&
        -:  525:		   !create_file("test4.txt", 40, fs) &&
        -:  526:		   !create_file("zero1.txt", 0, fs) &&
        -:  527:		   !delete_file("test1.txt", fs) &&
        -:  528:		   !delete_file("test3.txt", fs) &&
        -:  529:		   "failed to create file gaps");
        -:  530:
        1:  531:	repack(fs);
        -:  532:
        -:  533:	// TODO: Check filenames in o_list
        -:  534:
        1:  535:	close_fs(fs);
        1:  536:	return 0;
        -:  537:}
        -:  538:
        -:  539:// Tests the deletion of existing file
        1:  540:int test_delete_file_success() {
        1:  541:	gen_blank_files();
        1:  542:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  543:
        1:  544:	assert(!create_file("test1.txt", 50, fs) &&
        -:  545:		   !create_file("test2.txt", 50, fs) && "create failed");
        -:  546:
        1:  547:	assert(!delete_file("test1.txt", fs) && "delete failed");
        -:  548:
        -:  549:	// Check remaining entry in filesystem
        1:  550:	file_t* last = fs->n_list->list[0];
        1:  551:	assert(strncmp(last->name, "test2.txt", NAME_LEN - 1) == 0 &&
        -:  552:	       "incorrect file entry deleted");
        -:  553:
        1:  554:	close_fs(fs);
        1:  555:	return 0;
        -:  556:}
        -:  557:
        -:  558:// Attempts to delete files that do not exist
        1:  559:int test_delete_file_does_not_exist() {
        1:  560:	gen_blank_files();
        1:  561:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  562:
        1:  563:	assert(!create_file("test1.txt", 50, fs) && "create failed");
        -:  564:
        1:  565:	assert(delete_file("test2.txt", fs) == 1 && "delete should failed");
        -:  566:
        1:  567:	close_fs(fs);
        1:  568:	return 0;
        -:  569:}
        -:  570:
        -:  571:// Tests the renaming of existing files
        1:  572:int test_rename_file_success() {
        1:  573:	gen_blank_files();
        1:  574:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  575:
        1:  576:	assert(!create_file("bad.txt", 50, fs) && "create failed");
        -:  577:
        -:  578:	// Rename to different name
        1:  579:	assert(!rename_file("bad.txt", "good.txt", fs) && "rename failed");
        -:  580:
        -:  581:	// Rename to same name
        1:  582:	assert(!rename_file("good.txt", "good.txt", fs) &&
        -:  583:	       "rename to same name failed");
        -:  584:
        -:  585:	// Check name stored in filesystem
        1:  586:	file_t* f = fs->n_list->list[0];
        1:  587:	assert(strncmp(f->name, "good.txt", NAME_LEN - 1) == 0 &&
        -:  588:		   "incorrect file entry name");
        -:  589:
        1:  590:	close_fs(fs);
        1:  591:	return 0;
        -:  592:}
        -:  593:
        -:  594:// Attempts to rename files with conflicting name arguments
        1:  595:int test_rename_file_name_conflicts() {
        1:  596:	gen_blank_files();
        1:  597:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  598:
        1:  599:	assert(!create_file("bad.txt", 50, fs) &&
        -:  600:	       !create_file("okay.txt", 50, fs) && "create failed");
        -:  601:
        -:  602:	// Test oldname file not found
        1:  603:	assert(rename_file("worst.txt", "good.txt", fs) == 1 &&
        -:  604:	       "file not found should fail");
        -:  605:
        -:  606:	// Test newname file already exists
        1:  607:	assert(rename_file("bad.txt", "okay.txt", fs) == 1 &&
        -:  608:		   "file already exists should fail");
        -:  609:
        1:  610:	close_fs(fs);
        1:  611:	return 0;
        -:  612:}
        -:  613:
        -:  614:// Tests reading data from file_data
        1:  615:int test_read_file_success() {
        1:  616:	gen_blank_files();
        1:  617:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  618:
        1:  619:	assert(!create_file("basic.txt", 50, fs) && "create failed");
        -:  620:
        -:  621:	// Write to file_data
        1:  622:	char* write_buff = "content_to_read"; // String length of 15
        1:  623:	pwrite(file_fd, write_buff, 15, 0);
        1:  624:	fsync(file_fd);
        1:  625:	msync(fs->file, fs->file_data_len, MS_SYNC);
        -:  626:
        1:  627:	compute_hash_block(0, fs);
        1:  628:	msync(fs->hash, fs->hash_data_len, MS_SYNC);
        -:  629:
        1:  630:	char buff[16];
        -:  631:
        -:  632:	// Attempt to read 0 bytes
        1:  633:	assert(!read_file("basic.txt", 0, 0, buff, fs) && "zero byte read failed");
        -:  634:
        -:  635:	// Attempt to read 15 bytes
        1:  636:	assert(!read_file("basic.txt", 0, 15, buff, fs) && "read failed");
        1:  637:	buff[15] = '\0';
        -:  638:
        1:  639:	assert(strcmp(buff, write_buff) == 0 && "incorrect buffer content");
        -:  640:
        1:  641:	close_fs(fs);
        1:  642:	return 0;
        -:  643:}
        -:  644:
        -:  645:// Attempts to read from a file which does not exist
        1:  646:int test_read_file_does_not_exist() {
        1:  647:	gen_blank_files();
        1:  648:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  649:
        1:  650:	assert(!create_file("basic.txt", 50, fs) && "create failed");
        -:  651:
        1:  652:	char buff[50];
        1:  653:	assert(read_file("complex.txt", 0, 10, buff, fs) == 1 &&
        -:  654:	       "file read from does not exists");
        -:  655:
        1:  656:	close_fs(fs);
        1:  657:	return 0;
        -:  658:}
        -:  659:
        -:  660:// Attempts to read a file using an invalid offset and count
        1:  661:int test_read_file_invalid_offset_count() {
        1:  662:	gen_blank_files();
        1:  663:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  664:
        1:  665:	assert(!create_file("basic.txt", 50, fs) && "create failed");
        -:  666:
        1:  667:	char buff[50];
        1:  668:	assert(read_file("basic.txt", 45, 10, buff, fs) == 2 &&
        -:  669:		   "cannot read 10 bytes at offset 45");
        -:  670:
        1:  671:	close_fs(fs);
        1:  672:	return 0;
        -:  673:}
        -:  674:
        -:  675:// Attempts to read a file after hash_data has been externally modified
        1:  676:int test_read_file_invalid_hash() {
        1:  677:	gen_blank_files();
        1:  678:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  679:
        1:  680:	assert(!create_file("test1.txt", 50, fs) &&
        -:  681:		   !create_file("test2.txt", 27, fs) &&
        -:  682:		   "create failed");
        -:  683:
        -:  684:	// Write to file
        1:  685:	char* buff = "abc";
        1:  686:	assert(!write_file("test1.txt", 0, 3, buff, fs) &&
        -:  687:		   "write failed");
        -:  688:
        -:  689:	// Modify root hash value
        1:  690:	pwrite(hash_fd, "132", 3, 0);
        1:  691:	fsync(hash_fd);
        1:  692:	msync(fs->hash, fs->hash_data_len, MS_SYNC);
        -:  693:
        1:  694:	assert(read_file("test1.txt", 0, 3, buff, fs) == 3 &&
        -:  695:		   "hash verification should fail");
        -:  696:
        1:  697:	close_fs(fs);
        1:  698:	return 0;
        -:  699:}
        -:  700:
        -:  701:// Tests writing to file_data with repacking
        1:  702:int test_write_file_success() {
        1:  703:	gen_blank_files();
        1:  704:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  705:
        1:  706:	assert(!create_file("simple.txt", 950, fs) &&
        -:  707:		   !create_file("impossible.txt", 10, fs) &&
        -:  708:	       !create_file("basic.txt", 50, fs) &&
        -:  709:		   !create_file("complex.txt", 5, fs) && "create failed");
        -:  710:
        -:  711:	// Delete simple.txt to create space in filesystem
        1:  712:	assert(!delete_file("simple.txt", fs) && "delete failed");
        -:  713:
        1:  714:	char* write_buff = "content_to_write"; // String length of 16
        1:  715:	char buff[17];
        -:  716:
        -:  717:	// Write 0 bytes
        1:  718:	assert(!write_file("basic.txt", 0, 0, write_buff, fs) &&
        -:  719:	       "zero byte write failed");
        -:  720:
        -:  721:	// Write 16 bytes within file bounds
        1:  722:	assert(!write_file("basic.txt", 0, 16, write_buff, fs) && "write failed");
        -:  723:
        -:  724:	// Resize complex.txt to zero size file
        1:  725:	assert(!resize_file("complex.txt", 0, fs) && "resize failed");
        -:  726:
        -:  727:	// Write 16 bytes, expanding file bounds and repacking
        1:  728:	assert(!write_file("basic.txt", 50, 16, write_buff, fs) &&
        -:  729:	       "write extend failed");
        -:  730:
        1:  731:	assert(!read_file("basic.txt", 0, 16, buff, fs) && "read failed");
        1:  732:	buff[16] = '\0';
        -:  733:
        1:  734:	assert(strcmp(buff, write_buff) == 0 && "incorrect buffer content");
        -:  735:
        1:  736:	close_fs(fs);
        1:  737:	return 0;
        -:  738:}
        -:  739:
        -:  740:// Attempts to write to a file which does not exist
        1:  741:int test_write_file_does_not_exist() {
        1:  742:	gen_blank_files();
        1:  743:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  744:
        1:  745:	assert(!create_file("basic.txt", 50, fs) && "create failed");
        -:  746:
        1:  747:	assert(write_file("complex.txt", 0, 0, "write_content", fs) == 1 &&
        -:  748:		   "file written to does not exist");
        -:  749:
        1:  750:	close_fs(fs);
        1:  751:	return 0;
        -:  752:}
        -:  753:
        -:  754:// Attempts to write to a file using an invalid offset
        1:  755:int test_write_file_invalid_offset() {
        1:  756:	gen_blank_files();
        1:  757:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  758:
        1:  759:	assert(!create_file("basic.txt", 50, fs) &&
        -:  760:		   !create_file("complex.txt", 100, fs) && "create failed");
        -:  761:
        1:  762:	assert(write_file("complex.txt", 101, 13, "write_content", fs) == 2 &&
        -:  763:		   "offset beyond end of file");
        -:  764:
        1:  765:	close_fs(fs);
        1:  766:	return 0;
        -:  767:}
        -:  768:
        -:  769:// Attempts to perform a write which exceeds the capacity of file_data
        1:  770:int test_write_file_no_space() {
        1:  771:	gen_blank_files();
        1:  772:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  773:
        1:  774:	assert(!create_file("basic.txt", 50, fs) &&
        -:  775:		   !create_file("complex.txt", 100, fs) && "create failed");
        -:  776:
        -:  777:	// Write 1 byte over the maximum possible write size
        1:  778:	assert(write_file("complex.txt", 100, (F1_LEN - 150) + 1,
        -:  779:		   "write_content", fs) == 3 &&
        -:  780:		   "no space in filesystem for write operation");
        -:  781:
        1:  782:	close_fs(fs);
        1:  783:	return 0;
        -:  784:}
        -:  785:
        -:  786:// Tests the retrieval of file sizes
        1:  787:int test_file_size_success() {
        1:  788:	gen_blank_files();
        1:  789:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  790:
        1:  791:	assert(!create_file("big.txt", 50, fs) &&
        -:  792:		   !create_file("bigger.txt", 100, fs) && "create failed");
        -:  793:
        1:  794:	assert(file_size("big.txt", fs) == 50 &&
        -:  795:	       file_size("bigger.txt", fs) == 100 &&
        -:  796:	       "incorrect file sizes");
        -:  797:
        -:  798:	// Resize and rename file before checking size again
        1:  799:	assert(!resize_file("bigger.txt", 1, fs) &&
        -:  800:	       !rename_file("bigger.txt", "tiny.txt", fs) &&
        -:  801:	       file_size("tiny.txt", fs) == 1 &&
        -:  802:	       "incorrect file size after resize and rename");
        -:  803:
        1:  804:	close_fs(fs);
        1:  805:	return 0;
        -:  806:}
        -:  807:
        -:  808:// Attempts to find the size of a file which does not exist
        1:  809:int test_file_size_does_not_exist() {
        1:  810:	gen_blank_files();
        1:  811:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  812:
        1:  813:	assert(!create_file("big.txt", 50, fs) && "create failed");
        -:  814:
        1:  815:	assert(file_size("massive.txt", fs) == -1 &&
        -:  816:		   "file does not exist");
        -:  817:
        1:  818:	close_fs(fs);
        1:  819:	return 0;
        -:  820:}
        -:  821:
        -:  822:// Tests the fletcher hash function using expected and actual values
        1:  823:int test_fletcher_success() {
        -:  824:	// 4 * sizeof(uint32_t) = 16 bytes for hashing
        -:  825:	// Least significant byte of input[3] == 32 (0x20)
        1:  826:	uint32_t input[4] = {1000, 5361, 112, 20256};
        1:  827:	uint32_t sixteen_byte_expected[4] = {26729, 40563, 62758, 94314};
        1:  828:	uint32_t thirteen_byte_expected[4] = {6505, 20339, 42534, 74090};
        -:  829:
        1:  830:	uint32_t sixteen_byte_actual[4] = {0};
        1:  831:	uint32_t thirteen_byte_actual[4] = {0};
        -:  832:
        1:  833:	fletcher((uint8_t*)input, 16, (uint8_t*)sixteen_byte_actual);
        1:  834:	fletcher((uint8_t*)input, 13, (uint8_t*)thirteen_byte_actual);
        -:  835:
        -:  836:	// Compare fletcher output with expected values
        5:  837:	for (int i = 0; i < 4; ++i) {
        4:  838:		assert(sixteen_byte_actual[i] == sixteen_byte_expected[i] &&
        -:  839:			   "sixteen byte fletcher hash incorrect");
        -:  840:
        4:  841:		assert(thirteen_byte_actual[i] == thirteen_byte_expected[i] &&
        -:  842:			   "thirteen byte fletcher hash incorrect");
        -:  843:	}
        -:  844:
        1:  845:	return 0;
        -:  846:}
        -:  847:
        -:  848:// Tests compute_hash_tree for consistency with compute_hash_block
        -:  849:// using write_file calls and external writes to file_data
        1:  850:int test_compute_hash_tree_success() {
        1:  851:	gen_blank_files();
        1:  852:	filesys_t* fs = init_fs(f1, f2, f3, 1);
        -:  853:
        -:  854:	// Modify file_data using write_file and save root hash
        1:  855:	assert(!create_file("full_length.txt", 0, fs) && "create failed");
        -:  856:
        1:  857:	char* write_buff = "content_to_write"; // String length of 16
       65:  858:	for (int i = 0; i < F1_LEN; i += 16) {
       64:  859:		assert(!write_file("full_length.txt", i, 16, write_buff, fs) &&
        -:  860:		       "write failed");
        -:  861:	}
        -:  862:	
        1:  863:	uint8_t root_hash_expected[HASH_LEN];
        1:  864:	pread(hash_fd, root_hash_expected, HASH_LEN, 0);
        -:  865:
        1:  866:	close_fs(fs);
        -:  867:
        -:  868:	// Reset filesystem, pwrite to file_data and call compute_hash_tree
        1:  869:	gen_blank_files();
        1:  870:	fs = init_fs(f1, f2, f3, 1);
        -:  871:
       65:  872:	for (int i = 0; i < F1_LEN; i += 16) {
       64:  873:		pwrite(file_fd, write_buff, 16, i);
        -:  874:	}
        1:  875:	fsync(file_fd);
        1:  876:	msync(fs->hash, fs->hash_data_len, MS_SYNC);
        -:  877:
        1:  878:	compute_hash_tree(fs);
        -:  879:
        -:  880:	// Copy root hash and compare with expected
        1:  881:	uint8_t root_hash_actual[HASH_LEN];
        1:  882:	pread(hash_fd, root_hash_actual, HASH_LEN, 0);
        -:  883:
       17:  884:	for (int i = 0; i < HASH_LEN; ++i) {
       16:  885:		assert(root_hash_actual[i] == root_hash_expected[i] &&
        -:  886:		       "root hashes do not match");
        -:  887:	}
        -:  888:
        1:  889:	close_fs(fs);
        1:  890:	return 0;
        -:  891:}
        -:  892:
        -:  893:/*
        -:  894: * Main Method
        -:  895: */
        -:  896:
        1:  897:int main(int argc, char * argv[]) {
        1:  898:	error_count = 0;
        -:  899:
        -:  900:	// Create blank files for tests to use
        1:  901:	file_fd = open(f1, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
        1:  902:	dir_fd = open(f2, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
        1:  903:	hash_fd = open(f3, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
        1:  904:	assert(file_fd >= 0 && dir_fd >= 0 &&
        -:  905:		   hash_fd >= 0 && "failed to open files");
        1:  906:	gen_blank_files();
        -:  907:
        -:  908:	// Default tests
        1:  909:    TEST(success);
        1:  910:    TEST(failure);
        -:  911:
        -:  912:    // Helper tests
        1:  913:    TEST(test_helper_error_handling);
        -:  914:
        -:  915:    // Array data structure tests
        1:  916:	TEST(test_array_empty);
        1:  917:	TEST(test_array_insert);
        1:  918:	TEST(test_array_get);
        1:  919:	TEST(test_array_remove);
        -:  920:
        -:  921:	// Basic filesystem tests
        1:  922:	TEST(test_no_operation);
        1:  923:	TEST(test_init_close_error_handling);
        -:  924:
        -:  925:	// create_file tests
        1:  926:	TEST(test_create_file_success);
        1:  927:	TEST(test_create_file_exists);
        1:  928:	TEST(test_create_file_no_space);
        -:  929:
        -:  930:	// resize_file tests
        1:  931:	TEST(test_resize_file_success);
        1:  932:	TEST(test_resize_file_does_not_exist);
        1:  933:	TEST(test_resize_file_no_space);
        -:  934:
        -:  935:	// repack tests
        1:  936:	TEST(test_repack_success);
        -:  937:
        -:  938:	// delete_file tests
        1:  939:	TEST(test_delete_file_success);
        1:  940:	TEST(test_delete_file_does_not_exist);
        -:  941:
        -:  942:	// rename_file tests
        1:  943:	TEST(test_rename_file_success);
        1:  944:	TEST(test_rename_file_name_conflicts);
        -:  945:
        -:  946:	// read_file tests
        1:  947:	TEST(test_read_file_success);
        1:  948:	TEST(test_read_file_does_not_exist);
        1:  949:	TEST(test_read_file_invalid_offset_count);
        1:  950:	TEST(test_read_file_invalid_hash);
        -:  951:
        -:  952:	// write_file tests
        1:  953:	TEST(test_write_file_success);
        1:  954:	TEST(test_write_file_does_not_exist);
        1:  955:	TEST(test_write_file_invalid_offset);
        1:  956:	TEST(test_write_file_no_space);
        -:  957:
        -:  958:	// file_size tests
        1:  959:	TEST(test_file_size_success);
        1:  960:	TEST(test_file_size_does_not_exist);
        -:  961:
        -:  962:	// fletcher tests
        1:  963:	TEST(test_fletcher_success);
        -:  964:
        -:  965:	// compute_hash_tree tests
        1:  966:	TEST(test_compute_hash_tree_success);
        -:  967:
        -:  968:	// compute_hash_block is effectively tested by other test functions, being
        -:  969:	// used in methods such as create_file, resize_file, repack and write.
        -:  970:
        1:  971:	printf("Total Errors: %d\n", error_count);
        -:  972:
        1:  973:	close(file_fd);
        1:  974:	close(dir_fd);
        1:  975:	close(hash_fd);
        -:  976:
        1:  977:    return error_count;
        -:  978:}
        -:  979:
        -:  980:
