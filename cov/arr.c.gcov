        -:    0:Source:arr.c
        -:    0:Programs:4
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:#include <assert.h>
        -:    5:
        -:    6:#include "structs.h"
        -:    7:#include "helper.h"
        -:    8:#include "arr.h"
        -:    9:
        -:   10:/*
        -:   11: * Implementation of an array that sorts file_t structs based on name or offset
        -:   12: *
        -:   13: * The purpose of this array was to improve the efficiency of common operations
        -:   14: * such as finding a file by name, and performing a filesystem repack. An array
        -:   15: * sorted by name allows a binary search algorithm to be used for both the
        -:   16: * insertion of new files, and retrieval of existing files. Additionally, by
        -:   17: * iterating over an array sorted by offset, repack can be streamlined, as
        -:   18: * opposed to sorting files during each individual repack.
        -:   19: *
        -:   20: * Zero size files are assigned an offset equal to the maximum size of
        -:   21: * file_data (2^32), as it allows all new zero size files to be appended to end
        -:   22: * of the offset array, minimising the cost of create_file. Comparison of files
        -:   23: * using a key accounts for the insertion of zero size files at the end of the
        -:   24: * offset array, redirecting the binary search to lower indices.
        -:   25: *
        -:   26: * Although internally these files have an offset of 2^32, the offset update
        -:   27: * helper for dir_table writes 0 to the dir_table file, as expected by the
        -:   28: * filesystem specifications. To accommodate this, uint64_t is used instead
        -:   29: * of uint32_t.
        -:   30: */
        -:   31:
        -:   32:/*
        -:   33: * Compares the key field of file_t structs based on array type
        -:   34: *
        -:   35: * a: first file_t being compared
        -:   36: * b: second file_t being compared
        -:   37: * arr: address of array, used to determine array sorting type
        -:   38: *
        -:   39: * returns: -1, 0, or 1, representing the position of a relative to the
        -:   40: * 			position of b
        -:   41: */
      393:   42:int32_t cmp_key(file_t* a, file_t* b, arr_t* arr) {
      393:   43:	assert(a != NULL && b != NULL && arr != NULL && "invalid args");
        -:   44:	
      393:   45:	if (arr->type == OFFSET) {
       71:   46:		if (a->offset < b->offset) {
       28:   47:			return -1;
       43:   48:		} else if (a->offset > b->offset) {
       37:   49:			return 1;
        -:   50:		} else {
        -:   51:			// Check if file_t* b refers to a zero size file
        -:   52:			// (zero size files should be found by name, not offset)
        6:   53:			if (b->length > 0) {
        -:   54:				// Valid non-zero size file found
        3:   55:				return 0;
        -:   56:			} else {
        3:   57:				if (b->offset >= MAX_FILE_DATA_LEN) {
        -:   58:					// Redirect search to lower indices if encountering newly
        -:   59:					// created zero size file
        1:   60:					return -1;
        -:   61:				} else {
        -:   62:					// Redirect search to higher indices if encountering file
        -:   63:					// resized to 0 bytes
        2:   64:					return 1;
        -:   65:				}
        -:   66:			}
        -:   67:		}
        -:   68:	} else {
        -:   69:		// Only compare the first 63 characters of names
      322:   70:		return strncmp(a->name, b->name, NAME_LEN - 1);
        -:   71:	}
        -:   72:}
        -:   73:
        -:   74:/*
        -:   75: * Initialises an array with the fixed capacity and type specified
        -:   76: * A fixed capacity is used as the size of dir_table does not change over time
        -:   77: *
        -:   78: * capacity: maximum number of file_t struct pointers in array
        -:   79: * type: whether the array should be sorted by offset or name
        -:   80: *
        -:   81: * returns: address of dynamically allocated arr_t struct representing
        -:   82: * 			the array
        -:   83: * 			See structs.h for more information about arr_t fields
        -:   84: */
       64:   85:arr_t* arr_init(int32_t capacity, TYPE type, filesys_t* fs) {
       64:   86:	assert(capacity >= 0 && capacity <= MAX_NUM_FILES &&
        -:   87:	      (type == OFFSET || type == NAME) &&
        -:   88:	      fs != NULL && "invalid args");
        -:   89:	
       64:   90:	arr_t* arr = salloc(sizeof(*arr));
        -:   91:	
       64:   92:	arr->size = 0;
       64:   93:	arr->capacity = capacity;
       64:   94:	arr->type = type;
       64:   95:	arr->fs = fs;
       64:   96:	arr->list = salloc(sizeof(*arr->list) * capacity);
        -:   97:	
       64:   98:	return arr;
        -:   99:}
        -:  100:
        -:  101:/*
        -:  102: * Frees file_t structs pointed to by the array
        -:  103: *
        -:  104: * arr: address of arr_t struct containing file_t pointers to free
        -:  105: */
       64:  106:void free_arr_list(arr_t* arr) {
       64:  107:	assert(arr != NULL && "invalid args");
        -:  108:	
       64:  109:	if (arr->size > 0) {
       28:  110:		file_t** list = arr->list;
       97:  111:		for (int32_t i = 0; i < arr->size; ++i) {
       69:  112:			free_file(list[i]);
        -:  113:		}
        -:  114:		
        -:  115:		// Prevent double free
       28:  116:		arr->fs->o_list->size = 0;
       28:  117:		arr->fs->n_list->size = 0;
        -:  118:	}
       64:  119:}
        -:  120:
        -:  121:/*
        -:  122: * Frees arr_t struct files and file_t structs pointed to in the list
        -:  123: * of the array
        -:  124: *
        -:  125: * arr: address of arr_t struct containing file_t pointers to free
        -:  126: */
       64:  127:void free_arr(arr_t* arr) {
       64:  128:	assert(arr != NULL && "invalid args");
        -:  129:	
       64:  130:	free_arr_list(arr);
       64:  131:	free(arr->list);
       64:  132:	free(arr);
       64:  133:}
        -:  134:
        -:  135:/*
        -:  136: * Increase the index of elements from start to end by 1, creating
        -:  137: * space for insertion
        -:  138: *
        -:  139: * start: lowest array index being shifted
        -:  140: * end: highest array index being shifted
        -:  141: * arr: address of arr_t struct containing a list of file_t pointers
        -:  142: */
       39:  143:void arr_rshift(int32_t start, int32_t end, arr_t* arr) {
       39:  144:	TYPE type = arr->type;
       39:  145:	file_t** list = arr->list;
        -:  146:	
        -:  147:	// Iterate over array elements, incrementing the relevant
        -:  148:	// index and shifting pointers
      148:  149:	for (int32_t i = end; i >= start; --i) {
      109:  150:		if (type == OFFSET) {
       45:  151:			++list[i]->o_index;
        -:  152:		} else {
       64:  153:			++list[i]->n_index;
        -:  154:		}
      109:  155:		list[i + 1] = list[i];
        -:  156:	}
       39:  157:}
        -:  158:
        -:  159:/*
        -:  160: * Inserts file_t pointer at index specified, ensuring that elements remain
        -:  161: * adjacent after insertion
        -:  162: *
        -:  163: * index: position in array to insert file_t pointer
        -:  164: * file: file_t pointer being inserted into the array
        -:  165: * arr: address of arr_t struct containing a list of file_t pointers
        -:  166: *
        -:  167: * returns: index on success
        -:  168: */
      160:  169:int32_t arr_insert(int32_t index, file_t* file, arr_t* arr) {
      160:  170:	assert(file != NULL && arr != NULL && index >= 0 &&
        -:  171:	       index <= arr->size && "invalid args");
      160:  172:	assert(arr->size < arr->capacity && "array full");
        -:  173:	
        -:  174:	// Shift elements to the right (higher index) if required
      160:  175:	if (index < arr->size) {
       39:  176:		arr_rshift(index, arr->size - 1, arr);
        -:  177:	}
        -:  178:	
        -:  179:	// Update list and file_t variables
      160:  180:	arr->list[index] = file;
      160:  181:	++arr->size;
      160:  182:	if (arr->type == OFFSET) {
       83:  183:		file->o_index = index;
        -:  184:	} else {
       77:  185:		file->n_index = index;
        -:  186:	}
        -:  187:	
      160:  188:	return index;
        -:  189:}
        -:  190:
        -:  191:/*
        -:  192: * Get index for insertion of a new file_t pointer, or for an existing element
        -:  193: * Binary search is used to traverse the sorted array
        -:  194: * Zero size files are appended to the end of offset arrays
        -:  195: *
        -:  196: * file: file_t struct with the appropriate field populated for the array
        -:  197: * 		 (offset if offset sorted array, or name if name sorted array)
        -:  198: * arr: address of arr_t struct containing a list of file_t pointers
        -:  199: * insert: whether the function should return an index for insertion, or the
        -:  200: * 		   index of an existing file_t
        -:  201: *
        -:  202: * returns: if insert != 0 => insertion index on success, -1 if file exists
        -:  203: * 			if insert == 0 => file index on success, -1 if file not found
        -:  204: */
      346:  205:int32_t arr_get_index(file_t* file, arr_t* arr, int32_t insert) {
      346:  206:	assert(file != NULL && arr != NULL && "invalid args");
        -:  207:	
        -:  208:	// Cases when array is empty
      346:  209:	if (arr->size == 0) {
       80:  210:		if (insert) {
       57:  211:			return 0;
        -:  212:		} else {
       23:  213:			return -1;
        -:  214:		}
        -:  215:	}
        -:  216:	
        -:  217:	// Append zero size_files to end of offset array
      266:  218:	if (insert && arr->type == OFFSET && file->length == 0) {
       21:  219:		return arr->size;
        -:  220:	}
        -:  221:	
      245:  222:	int32_t size = arr->size;
      245:  223:	file_t** list = arr->list;
        -:  224:	
        -:  225:	// Index variables for low, high and middle index of binary search
      245:  226:	int32_t l = 0;
      245:  227:	int32_t h = size - 1;
      245:  228:	int32_t m = 0;
      245:  229:	int32_t cmp = 0;
        -:  230:	
        -:  231:	// Loop until file_t found, or low and high converge with the middle index
        -:  232:	while (1) {
      537:  233:		m = (l + h) / 2;
      391:  234:		cmp = cmp_key(file, list[m], arr);
        -:  235:
      391:  236:		if (cmp < 0) {
        -:  237:			// Check for low and middle index convergence
       91:  238:			if (l >= m) {
       39:  239:				if (insert) {
       31:  240:					return m; // Insert at current index
        -:  241:				} else {
        8:  242:					return -1; // File not found
        -:  243:				}
        -:  244:			}
        -:  245:			
        -:  246:			// Update high index for next iteration
       52:  247:			h = m - 1;
        -:  248:			
      300:  249:		} else if (cmp > 0) {
        -:  250:			// Check for high and middle index convergence
      187:  251:			if (h <= m) {
       93:  252:				if (insert) {
       51:  253:					return m + 1; // Insert at next index
        -:  254:				} else {
       42:  255:					return -1; // File not found
        -:  256:				}
        -:  257:			}
        -:  258:			
        -:  259:			// Update low index for next iteration
       94:  260:			l = m + 1;
        -:  261:			
        -:  262:		} else {
      113:  263:			if (insert) {
        2:  264:				return -1; // File exists
        -:  265:			} else {
      111:  266:				return m; // Return index of file found
        -:  267:			}
        -:  268:		}
        -:  269:	}
        -:  270:}
        -:  271:
        -:  272:/*
        -:  273: * Sorted insertion of a file_t struct into an array
        -:  274: *
        -:  275: * file: address of file_t being inserted into the array
        -:  276: * arr: address of arr_t struct containing a list of file_t pointers
        -:  277: *
        -:  278: * returns: index on success, -1 if file exists
        -:  279: */
      162:  280:int32_t arr_sorted_insert(file_t* file, arr_t* arr) {
      162:  281:	assert(file != NULL && arr != NULL && "invalid args");
      162:  282:	assert(arr->size < arr->capacity && "array full");
        -:  283:	
        -:  284:	// Find insertion index
      162:  285:	int32_t index = arr_get_index(file, arr, 1);
      162:  286:	if (index < 0) {
        2:  287:		return -1; // File exists
        -:  288:	}
        -:  289:
      160:  290:	arr_insert(index, file, arr);
      160:  291:	return index;
        -:  292:}
        -:  293:
        -:  294:/*
        -:  295: * Decrease the index of elements from start to end by 1, overwriting the
        -:  296: * address of a file_t pointer being removed
        -:  297: *
        -:  298: * start: lowest array index being shifted
        -:  299: * end: highest array index being shifted
        -:  300: * arr: address of arr_t struct containing a list of file_t pointers
        -:  301: */
       19:  302:void arr_lshift(int32_t start, int32_t end, arr_t* arr) {
       19:  303:	TYPE type = arr->type;
       19:  304:	file_t** list = arr->list;
        -:  305:	
        -:  306:	// Iterate over array elements, decrementing the relevant index
        -:  307:	// and shifting pointers
       69:  308:	for (int32_t i = start; i <= end; ++i) {
       50:  309:		if (type == OFFSET) {
       30:  310:			--list[i]->o_index;
        -:  311:		} else {
       20:  312:			--list[i]->n_index;
        -:  313:		}
       50:  314:		list[i - 1] = list[i];
        -:  315:	}
       19:  316:}
        -:  317:
        -:  318:/*
        -:  319: * Removes file_t pointer at index specified, ensuring that elements remain
        -:  320: * adjacent after removal
        -:  321: * NO MEMORY IS FREED DURING THIS PROCESS
        -:  322: *
        -:  323: * index: position in array to insert file_t pointer
        -:  324: * arr: address of arr_t struct containing a list of file_t pointers
        -:  325: *
        -:  326: * returns: file_t pointer removed on success
        -:  327: */
       22:  328:file_t* arr_remove(int32_t index, arr_t* arr) {
       22:  329:	assert(arr != NULL && index >= 0 && index < arr->size && "invalid args");
       22:  330:	assert(arr->size > 0 && "array empty");
        -:  331:	
        -:  332:	// Retrieve file_t* from array
       22:  333:	file_t* f = arr_get(index, arr);
        -:  334:	
        -:  335:	// Shift elements to the left (lower index) if required
       22:  336:	if (index < arr->size - 1) {
       19:  337:		arr_lshift(index + 1, arr->size - 1, arr);
        -:  338:	}
        -:  339:	
        -:  340:	// Update list and file_t variables
       22:  341:	arr->size--;
       22:  342:	if (arr->type == OFFSET) {
       14:  343:		f->o_index = -1;
        -:  344:	} else {
        8:  345:		f->n_index = -1;
        -:  346:	}
        -:  347:	
       22:  348:	return f;
        -:  349:}
        -:  350:
        -:  351:/*
        -:  352: * Removal of a file_t struct from an array using a key
        -:  353: *
        -:  354: * key: address of file_t with same key as file being removed
        -:  355: * arr: address of arr_t struct containing a list of file_t pointers
        -:  356: *
        -:  357: * returns: removed file_t* on success
        -:  358: * 			NULL if file not found or invalid key
        -:  359: */
        5:  360:file_t* arr_remove_by_key(file_t* key, arr_t* arr) {
        5:  361:	assert(key != NULL && arr != NULL && "invalid args");
        -:  362:
        -:  363:	// Check for valid key value
        8:  364:	if ((arr->type == OFFSET && (key->offset < 0 ||
        7:  365:		key->offset >= arr->fs->file_data_len)) ||
        6:  366:		(arr->type == NAME  && key->name[0] == '\0')) {
        1:  367:		return NULL;
        -:  368:	}
        -:  369:	
        -:  370:	// Find file_t index in array (return NULL if file not found)
        4:  371:	file_t* f = arr_get_by_key(key, arr);
        4:  372:	if (f == NULL) {
        2:  373:		return NULL;
        -:  374:	}
        -:  375:
        -:  376:	// Remove depending on type of array
        2:  377:	if (arr->type == OFFSET) {
        1:  378:		arr_remove(f->o_index, arr);
        -:  379:	} else {
        1:  380:		arr_remove(f->n_index, arr);
        -:  381:	}
        -:  382:	
        2:  383:	return f;
        -:  384:}
        -:  385:
        -:  386:/*
        -:  387: * Retrieves the file_t pointer at the given index of an array
        -:  388: *
        -:  389: * index: position of file_t* in array
        -:  390: * arr: address of arr_t struct containing a list of file_t pointers
        -:  391: */
      133:  392:file_t* arr_get(int32_t index, arr_t* arr) {
      133:  393:	assert(index >= 0 && arr != NULL && index < arr->size && "invalid args");
        -:  394:
      133:  395:	return arr->list[index];
        -:  396:}
        -:  397:
        -:  398:/*
        -:  399: * Searches through the list of file_t pointers in an arr_t struct for an
        -:  400: * element with a matching key value
        -:  401: *
        -:  402: * key: address of a file_t struct with the appropriate field for the array
        -:  403: * 		type populated
        -:  404: * arr: address of arr_t struct containing a list of file_t pointers
        -:  405: *
        -:  406: * returns: file_t* of matching file in array on success
        -:  407: * 			NULL if file not found or invalid key
        -:  408: */
      185:  409:file_t* arr_get_by_key(file_t* key, arr_t* arr) {
      185:  410:	assert(key != NULL && arr != NULL && "invalid args");
        -:  411:	
        -:  412:	// Check for valid key value
      190:  413:	if ((arr->type == OFFSET && (key->offset < 0 ||
      189:  414:		key->offset >= arr->fs->file_data_len)) ||
      364:  415:		(arr->type == NAME  && key->name[0] == '\0')) {
        1:  416:		return NULL;
        -:  417:	}
        -:  418:	
        -:  419:	// Check if file exists (return NULL if file not found)
      184:  420:	int32_t index = arr_get_index(key, arr, 0);
      184:  421:	if (index < 0) {
       73:  422:		return NULL;
        -:  423:	}
        -:  424:	
      111:  425:	return arr_get(index, arr);
        -:  426:}
