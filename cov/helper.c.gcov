        -:    0:Source:helper.c
        -:    0:Programs:4
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <stdint.h>
        -:    4:#include <string.h>
        -:    5:#include <unistd.h>
        -:    6:#include <sys/mman.h>
        -:    7:#include <assert.h>
        -:    8:
        -:    9:#include "structs.h"
        -:   10:#include "helper.h"
        -:   11:
        -:   12:/*
        -:   13: * Safe malloc helper with error checking
        -:   14: *
        -:   15: * size: number of bytes in heap memory which should be allocated
        -:   16: *
        -:   17: * returns: address to block in heap memory of specified size
        -:   18: */
      241:   19:void* salloc(size_t size) {
      241:   20:	void* m = malloc(size);
      241:   21:	assert(m != NULL && "malloc failed");
      241:   22:	return m;
        -:   23:}
        -:   24:
        -:   25:/*
        -:   26: * Safe calloc helper with error checking
        -:   27: *
        -:   28: * size: number of bytes in heap memory which should be allocated
        -:   29: *
        -:   30: * returns: address to block in heap memory of specified size, with all bytes
        -:   31: * 			set to 0.
        -:   32: */
       31:   33:void* scalloc(size_t size) {
       31:   34:	void* m = calloc(size, 1);
       31:   35:	assert(m != NULL && "calloc failed");
       31:   36:	return m;
        -:   37:}
        -:   38:
        -:   39:/*
        -:   40: * Creates a new dynamically allocated file_t struct
        -:   41: *
        -:   42: * name: name of file
        -:   43: * offset: file offset in file_data
        -:   44: * length: number of bytes in file_data used by file
        -:   45: * index: entry number in dir_table
        -:   46: *
        -:   47: * returns: address of heap allocated file_t struct
        -:   48: */
       78:   49:file_t* file_init(char* name, uint64_t offset, uint32_t length, int32_t index) {
       78:   50:	file_t* f = salloc(sizeof(*f));
       78:   51:	update_file_name(name, f);
       78:   52:	update_file_offset(offset, f);
       78:   53:	update_file_length(length, f);
       78:   54:	f->index = index;
       78:   55:	f->o_index = -1;
       78:   56:	f->n_index = -1;
       78:   57:	return f;
        -:   58:}
        -:   59:
        -:   60:/*
        -:   61: * Frees file_t struct
        -:   62: *
        -:   63: * file: address of heap allocated file_t struct being freed
        -:   64: */
       75:   65:void free_file(file_t* file) {
       75:   66:	free(file);
       75:   67:}
        -:   68:
        -:   69:/*
        -:   70: * Updates name field of file_t struct
        -:   71: * Other file_t field update helpers are defined as macros in helper.h
        -:   72: *
        -:   73: * name: new name for file_t struct
        -:   74: * file: address of heap allocated file_t struct to update
        -:   75: */
      261:   76:void update_file_name(char* name, file_t* file) {
      261:   77:	strncpy(file->name, name, NAME_LEN - 1);
      261:   78:	file->name[NAME_LEN - 1] = '\0';
      261:   79:}
        -:   80:
        -:   81:/*
        -:   82: * Updates the offset field for a file in dir_table
        -:   83: * Other dir_table field update helpers are defined as macros in helper.h
        -:   84: *
        -:   85: * file: address of heap allocated file_t struct to update
        -:   86: */
       74:   87:void update_dir_offset(file_t* file, filesys_t* fs) {
        -:   88:	// Write 0 to dir_table if newly created zero size file
       74:   89:	if (file->offset >=  MAX_FILE_DATA_LEN) {
       17:   90:		memset(fs->dir + file->index * META_LEN + NAME_LEN,
        -:   91:			   '\0', sizeof(uint32_t));
        -:   92:
        -:   93:	// Otherwise write the internal file offset to dir_table
        -:   94:	} else {
       57:   95:		memcpy(fs->dir + file->index * META_LEN + NAME_LEN,
       57:   96:			   &file->offset, sizeof(uint32_t));
        -:   97:	}
       74:   98:}
        -:   99:
        -:  100:/*
        -:  101: * Writes file_t fields to dir_table at its index
        -:  102: *
        -:  103: * file: address of heap allocated file_t struct to update
        -:  104: */
       59:  105:void write_dir_file(file_t* file, filesys_t* fs) {
       59:  106:	update_dir_name(file, fs);
       59:  107:	update_dir_offset(file, fs);
       59:  108:	update_dir_length(file, fs);
       59:  109:}
        -:  110:
        -:  111:/*
        -:  112: * Finds the first non-zero size file in file_data, starting at index
        -:  113: *
        -:  114: * index: first index to start searching for non-zero size files
        -:  115: * o_list: address of offset sorted array
        -:  116: *
        -:  117: * returns: file_t* for first non-zero size file from index
        -:  118: * 			to the end of the array
        -:  119: * 			NULL if no non-zero size files found
        -:  120: */
      154:  121:file_t* find_next_nonzero_file(int32_t index, arr_t* arr) {
      154:  122:	file_t** o_list = arr->list;
      154:  123:	int32_t size = arr->size;
      154:  124:	uint64_t start_curr_file = 0;
      154:  125:	uint64_t curr_file_len = 0;
        -:  126:
      159:  127:	for (int32_t i = index; i < size; ++i) {
       59:  128:		start_curr_file = o_list[i]->offset;
       59:  129:		curr_file_len = o_list[i]->length;
        -:  130:
        -:  131:		// Break if newly created zero size files encountered
       59:  132:		if (start_curr_file >= MAX_FILE_DATA_LEN) {
       11:  133:			break;
        -:  134:		}
        -:  135:
        -:  136:		// Non-zero size file found
       48:  137:		if (curr_file_len > 0) {
       43:  138:			return o_list[i];
        -:  139:		}
        -:  140:	}
        -:  141:
      111:  142:	return NULL;
        -:  143:}
        -:  144:
        -:  145:/*
        -:  146: * Writes null bytes to a memory mapped file (mmap) at the offset specified
        -:  147: *
        -:  148: * f: pointer to start of a memory mapped file
        -:  149: * offset: offset from the beginning of the file to write null bytes at
        -:  150: * count: number of null bytes to write
        -:  151: *
        -:  152: * returns: number of null bytes written
        -:  153: */
       56:  154:uint64_t write_null_byte(uint8_t* f, int64_t offset, int64_t count) {
        -:  155:	// Return if no bytes to write
       56:  156:	if (count <= 0) {
        1:  157:		return 0;
        -:  158:	}
        -:  159:
       55:  160:	assert(count < MAX_FILE_DATA_LEN && offset >= 0 &&
        -:  161:	       offset < MAX_FILE_DATA_LEN && "invalid args");
        -:  162:	
        -:  163:	// Write null bytes to file
       55:  164:	memset(f + offset, '\0', count);
       55:  165:	return count;
        -:  166:}
        -:  167:
        -:  168:/*
        -:  169: * Writes count null bytes to a file descriptor at offset
        -:  170: *
        -:  171: * fd: file descriptor to write to
        -:  172: * offset: offset from the beginning of the file to write null bytes at
        -:  173: * count: number of null bytes to write
        -:  174: *
        -:  175: * returns: number of null bytes written
        -:  176: */
       94:  177:uint64_t pwrite_null_byte(int fd, int64_t offset, int64_t count) {
        -:  178:	// Return if no bytes to write
       94:  179:	if (count <= 0) {
        1:  180:		return 0;
        -:  181:	}
        -:  182:
       93:  183:	assert(fd >= 0 && count <= MAX_FILE_DATA_LEN &&
        -:  184:	       offset <= MAX_FILE_DATA_LEN && "invalid args");
        -:  185:
    57629:  186:	for (int64_t i = 0; i < count; ++i) {
    57536:  187:		pwrite(fd, "", sizeof(char), offset + i);
        -:  188:	}
        -:  189:
       93:  190:	return count;
        -:  191:}
